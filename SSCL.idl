//==============================================================================
// Copyright (c) 2000  -  Triopoint Systems, Inc.
//
// Module Name: SSCL.idl
//
// Author(s): Jeff Boenig
//
// Description: ShapeShifter interface definitions.
//
//==============================================================================

import "oaidl.idl";
import "ocidl.idl";
import "msxml.idl";

#include "olectl.h"

#include "CategorizeProperties.idl"

// Forward declarations
interface IEngine;
interface IDevice;
interface IModel;
interface IViewport;
interface IController;

#include "ShapeShifterDispId.h"

// Description:
//    This type is used to reference vertices in a primitive.
typedef long VertexIndex;

// Description:
//    This type is used to store the number of vertices in a primitive.
typedef long VertexCount;

// Description:
//    This type is used to reference vertices in a mesh's vertex buffer.
typedef long VertexHandle;

// Description:
//    This type is used to reference faces in a mesh.
typedef long FaceIndex;

// Description:
//    This type is used to store the number of faces in a mesh.
typedef long FaceCount;

// Description:
//    This type is used to reference primitives in a mesh.
typedef long PrimitiveIndex;

// Description:
//    This type is used to store the number of primitives in a mesh.
typedef long PrimitiveCount;

// Description:
//    This type is used to store identifiers (i.e. handles) for resources
//    on a device.
typedef long DeviceResourceId;

typedef float VALUE3D, *LPVALUE3D;

[
	helpstring("Device Driver Modes"),
	v1_enum
]
// Description:
//    Device driver modes that can be used to access a device.
//
// Remarks:
//     SSCL_HAL - Hardware rasterization and shading with software,
//                hardware, or mixed transform and lighting.
//     SSCL_REF - Reference device that implements driver features in
//                software, but makes use of special CPU instructions
//                when possible.
//     SSCL_SW  - A pluggable software device.
//
//    The values above map directly onto the Direct3D device types
//    D3DDEVTYPE_HAL, D3DDEVTYPE_REF, and D3DDEVTYPE_SW.
//
// See Also:
//    Device
enum DriverMode
{
	[helpstring("Hardware Abstraction Layer Mode")] SSCL_HAL = 1,
	[helpstring("Reference Device Mode")] SSCL_REF = 2,
	[helpstring("Software Device Mode")] SSCL_SW = 3
};

[
	helpstring("Input Device Types"),
	v1_enum
]
// Description:
//    Describes a category of input device. Each input device belongs to
//    one category.
//
// Remarks:
//    Input devices are attached to controllers. Multiple input devices can
//    be attached to a single controller, but only one device in a given
//    category can be attached at a time.
//
// See Also:
//    IInputDevice, InputDevice, IController
enum InputDeviceCategory
{
	[helpstring("Keyboard")] SSCL_KEYBOARD = 0,
	[helpstring("Mouse")] SSCL_MOUSE = 1,
	[helpstring("Joystick")] SSCL_JOYSTICK = 2,
	[helpstring("Game Pad")] SSCL_GAMEPAD = 3,
	[helpstring("Flight controller")] SSCL_FLIGHT = 4,
	[helpstring("Steering wheel")] SSCL_DRIVING = 5,
	[helpstring("1st person controller")] SSCL_1ST_PERSON = 6,
	[helpstring("Screen pointer")] SSCL_SCREEN_POINTER = 7
};

[
	helpstring("Units of measure"),
	v1_enum
]
// Description:
//    Real world units of measurement that can be used with ShapeShifter.
//
// Remarks:
//    ShapeShifter supports conversion between logical units and all of the
//    units of measurement defined by this enum. Conversion between different
//    units of measurement is also supported.
//
// See Also:
//    IMeasurementScale, IModel
enum UnitOfMeasure
{
	[helpstring("Logical Units")] SR_LOGICAL_UNITS = -1,
	[helpstring("Inches")] SR_INCHES = 0,
	[helpstring("Feet")] SR_FEET = 1,
	[helpstring("Yards")] SR_YARDS = 2,
	[helpstring("Statue Miles")] SR_STATUE_MILES = 3,
	[helpstring("Millimeters")] SR_MILLIMETERS = 4,
	[helpstring("Centimeters")] SR_CENTIMETERS = 5,
	[helpstring("Meters")] SR_METERS = 6,
	[helpstring("Kilometers")] SR_KILOMETERS = 7,
	[helpstring("US Survey Feet")] SR_FEET_US_SURVEY = 8,
	[helpstring("Angstroms")] SR_ANGSTROMS = 9,
	[helpstring("Microns")] SR_MICRONS = 10,
	[helpstring("Micro Inches")] SR_MICROINCHES = 11,
	[helpstring("Chains")] SR_CHAINS = 12,
	[helpstring("Fathoms")] SR_FATHOMS = 13,
	[helpstring("Rods")] SR_RODS = 14,
	[helpstring("Fermis")] SR_FERMIS = 15,
	[helpstring("Nautical Miles")] SR_NAUTICAL_MILES = 16,
	[helpstring("International Miles")] SR_INTL_MILES = 17,
	[helpstring("Light Years")] SR_LIGHTYEARS = 18,
	[helpstring("Parsecs")] SR_PARSECS = 19,
	[helpstring("Astronomical Units")] SR_ASTRONOMICAL_UNITS = 20,
	[helpstring("Points")] SR_POINTS = 21,
	[helpstring("Picas")] SR_PICAS = 22
};

[
	helpstring("Primitive Types"),
	v1_enum
]
// Description:
//    This enumeration defines the types of primitives that a mesh can be
//    constructed from.
//
// See Also:
//    IMesh
enum PrimitiveType
{
	[helpstring("Help")] SSCL_UNKNOWN_PRIMITIVE = 0,
	[helpstring("Help")] SSCL_POINTLIST = 1,
	[helpstring("Help")] SSCL_LINELIST = 2,
	[helpstring("Help")] SSCL_LINESTRIP = 3,
	[helpstring("Help")] SSCL_TRIANGLELIST = 4,
	[helpstring("Help")] SSCL_TRIANGLESTRIP = 5,
	[helpstring("Help")] SSCL_TRIANGLEFAN = 6
};

[
	helpstring("Render State Types"),
	v1_enum
]
// Description:
//    This enumeration defines an identifier for each type of render state.
//
// Remarks:
//    Render states define settings used while rendering one or more objects.
//    Render states are set using the function IRenderingContext::SetRenderState,
//    which passes the render state type and value straight through to Direct3D.
//    The values of this enumeration map directly onto the values of the
//    Direct3D enumeration D3DRENDERSTATETYPE. C++ clients can use the
//    Direct3D enumeration directly. This enumeration is defined for the
//    convenience of other languages.
//
// See Also:
//    IRenderingContext
enum RenderStateType
{
    [helpstring("Help")] SSCLRS_ANTIALIAS          = 2,    /* D3DANTIALIASMODE */
    [helpstring("Help")] SSCLRS_TEXTUREPERSPECTIVE = 4,    /* TRUE for perspective correction */
    [helpstring("Help")] SSCLRS_ZENABLE            = 7,    /* D3DZBUFFERTYPE (or TRUE/FALSE for legacy) */
    [helpstring("Help")] SSCLRS_FILLMODE           = 8,    /* D3DFILL_MODE        */
    [helpstring("Help")] SSCLRS_SHADEMODE          = 9,    /* D3DSHADEMODE */
    [helpstring("Help")] SSCLRS_LINEPATTERN        = 10,   /* D3DLINEPATTERN */
    [helpstring("Help")] SSCLRS_ZWRITEENABLE       = 14,   /* TRUE to enable z writes */
    [helpstring("Help")] SSCLRS_ALPHATESTENABLE    = 15,   /* TRUE to enable alpha tests */
    [helpstring("Help")] SSCLRS_LASTPIXEL          = 16,   /* TRUE for last-pixel on lines */
    [helpstring("Help")] SSCLRS_SRCBLEND           = 19,   /* D3DBLEND */
    [helpstring("Help")] SSCLRS_DESTBLEND          = 20,   /* D3DBLEND */
    [helpstring("Help")] SSCLRS_CULLMODE           = 22,   /* D3DCULL */
    [helpstring("Help")] SSCLRS_ZFUNC              = 23,   /* D3DCMPFUNC */
    [helpstring("Help")] SSCLRS_ALPHAREF           = 24,   /* D3DFIXED */
    [helpstring("Help")] SSCLRS_ALPHAFUNC          = 25,   /* D3DCMPFUNC */
    [helpstring("Help")] SSCLRS_DITHERENABLE       = 26,   /* TRUE to enable dithering */
    [helpstring("Help")] SSCLRS_ALPHABLENDENABLE   = 27,   /* TRUE to enable alpha blending */
    [helpstring("Help")] SSCLRS_FOGENABLE          = 28,   /* TRUE to enable fog blending */
    [helpstring("Help")] SSCLRS_SPECULARENABLE     = 29,   /* TRUE to enable specular */
    [helpstring("Help")] SSCLRS_ZVISIBLE           = 30,   /* TRUE to enable z checking */
    [helpstring("Help")] SSCLRS_STIPPLEDALPHA      = 33,   /* TRUE to enable stippled alpha (RGB device only) */
    [helpstring("Help")] SSCLRS_FOGCOLOR           = 34,   /* D3DCOLOR */
    [helpstring("Help")] SSCLRS_FOGTABLEMODE       = 35,   /* D3DFOGMODE */
    [helpstring("Help")] SSCLRS_FOGSTART           = 36,   /* Fog start (for both vertex and pixel fog) */
    [helpstring("Help")] SSCLRS_FOGEND             = 37,   /* Fog end      */
    [helpstring("Help")] SSCLRS_FOGDENSITY         = 38,   /* Fog density  */
    [helpstring("Help")] SSCLRS_EDGEANTIALIAS      = 40,   /* TRUE to enable edge antialiasing */
    [helpstring("Help")] SSCLRS_COLORKEYENABLE     = 41,   /* TRUE to enable source colorkeyed textures */
    [helpstring("Help")] SSCLRS_ZBIAS              = 47,   /* LONG Z bias */
    [helpstring("Help")] SSCLRS_RANGEFOGENABLE     = 48,   /* Enables range-based fog */
    [helpstring("Help")] SSCLRS_STENCILENABLE      = 52,   /* BOOL enable/disable stenciling */
    [helpstring("Help")] SSCLRS_STENCILFAIL        = 53,   /* D3DSTENCILOP to do if stencil test fails */
    [helpstring("Help")] SSCLRS_STENCILZFAIL       = 54,   /* D3DSTENCILOP to do if stencil test passes and Z test fails */
    [helpstring("Help")] SSCLRS_STENCILPASS        = 55,   /* D3DSTENCILOP to do if both stencil and Z tests pass */
    [helpstring("Help")] SSCLRS_STENCILFUNC        = 56,   /* D3DCMPFUNC fn.  Stencil Test passes if ((ref & mask) stencilfn (stencil & mask)) is true */
    [helpstring("Help")] SSCLRS_STENCILREF         = 57,   /* Reference value used in stencil test */
    [helpstring("Help")] SSCLRS_STENCILMASK        = 58,   /* Mask value used in stencil test */
    [helpstring("Help")] SSCLRS_STENCILWRITEMASK   = 59,   /* Write mask applied to values written to stencil buffer */
    [helpstring("Help")] SSCLRS_TEXTUREFACTOR      = 60,   /* D3DCOLOR used for multi-texture blend */
    [helpstring("Help")] SSCLRS_WRAP0              = 128,  /* wrap for 1st texture coord. set */
    [helpstring("Help")] SSCLRS_WRAP1              = 129,  /* wrap for 2nd texture coord. set */
    [helpstring("Help")] SSCLRS_WRAP2              = 130,  /* wrap for 3rd texture coord. set */
    [helpstring("Help")] SSCLRS_WRAP3              = 131,  /* wrap for 4th texture coord. set */
    [helpstring("Help")] SSCLRS_WRAP4              = 132,  /* wrap for 5th texture coord. set */
    [helpstring("Help")] SSCLRS_WRAP5              = 133,  /* wrap for 6th texture coord. set */
    [helpstring("Help")] SSCLRS_WRAP6              = 134,  /* wrap for 7th texture coord. set */
    [helpstring("Help")] SSCLRS_WRAP7              = 135,  /* wrap for 8th texture coord. set */
    [helpstring("Help")] SSCLRS_CLIPPING            = 136,
    [helpstring("Help")] SSCLRS_LIGHTING            = 137,
    [helpstring("Help")] SSCLRS_EXTENTS             = 138,
    [helpstring("Help")] SSCLRS_AMBIENT             = 139,
    [helpstring("Help")] SSCLRS_FOGVERTEXMODE       = 140,
    [helpstring("Help")] SSCLRS_COLORVERTEX         = 141,
    [helpstring("Help")] SSCLRS_LOCALVIEWER         = 142,
    [helpstring("Help")] SSCLRS_NORMALIZENORMALS    = 143,
    [helpstring("Help")] SSCLRS_COLORKEYBLENDENABLE = 144,
    [helpstring("Help")] SSCLRS_DIFFUSEMATERIALSOURCE    = 145,
    [helpstring("Help")] SSCLRS_SPECULARMATERIALSOURCE   = 146,
    [helpstring("Help")] SSCLRS_AMBIENTMATERIALSOURCE    = 147,
    [helpstring("Help")] SSCLRS_EMISSIVEMATERIALSOURCE   = 148,
    [helpstring("Help")] SSCLRS_VERTEXBLEND              = 151,
    [helpstring("Help")] SSCLRS_CLIPPLANEENABLE          = 152,
};

[
	helpstring("Texture Stage State Types"),
	v1_enum
]
// Description:
//    This enumeration defines an identifier for each type of texture stage state.
//
// Remarks:
//    Texture stage states define settings used for mapping textures. Texture
//    stage states are set using functions defined in ITextureStage. The values
//    passed to ITextureStage are passed straight through to Direct3D. The values
//    of this enumeration map directly onto the values of the Direct3D enumeration
//    D3DTEXTURESTAGESTATETYPE. C++ clients can use the Direct3D enumeration
//    directly. This enumeration is defined for the convenience of other languages.
//
// See Also:
//    ITextureStage
enum TextureStageStateType
{
	[helpstring("Help")] SSCL_COLOROP = 1,
	[helpstring("Help")] SSCL_COLORARG1 = 2,
	[helpstring("Help")] SSCL_COLORARG2 = 3,
	[helpstring("Help")] SSCL_ALPHAOP = 4,
	[helpstring("Help")] SSCL_ALPHAARG1 = 5,
	[helpstring("Help")] SSCL_ALPHAARG2 = 6,
	[helpstring("Help")] SSCL_BUMPENVMAT00 = 7,
	[helpstring("Help")] SSCL_BUMPENVMAT01 = 8,
	[helpstring("Help")] SSCL_BUMPENVMAT10 = 9,
	[helpstring("Help")] SSCL_BUMPENVMAT11 = 10,
	[helpstring("Help")] SSCL_TEXCOORDINDEX = 11,
	[helpstring("Help")] SSCL_ADDRESS = 12,
	[helpstring("Help")] SSCL_ADDRESSU = 13,
	[helpstring("Help")] SSCL_ADDRESSV = 14,
	[helpstring("Help")] SSCL_BORDERCOLOR = 15,
	[helpstring("Help")] SSCL_MAGFILTER = 16,
	[helpstring("Help")] SSCL_MINFILTER = 17,
	[helpstring("Help")] SSCL_MIPFILTER = 18,
	[helpstring("Help")] SSCL_MIPMAPLODBIAS = 19,
	[helpstring("Help")] SSCL_MAXMIPLEVEL = 20,
	[helpstring("Help")] SSCL_MAXANISOTROPY = 21,
	[helpstring("Help")] SSCL_BUMPENVLSCALE = 22,
	[helpstring("Help")] SSCL_BUMPENVLOFFSET = 23,
	[helpstring("Help")] SSCL_TEXTURETRANSFORMFLAGS = 24,
	[helpstring("Help")] SSCL_ADDRESSW = 25,
	[helpstring("Help")] SSCL_COLORARG0 = 26,
	[helpstring("Help")] SSCL_ALPHAARG0 = 27,
	[helpstring("Help")] SSCL_RESULTARG = 28
};

[
	helpstring("Texture Filter Settings"),
	v1_enum
]
// Description:
//    Defines the types of texture filtering available.
//
// Remarks:
//    Texture filtering is the process of mapping the texture color of a point
//    on the polygon to a 2D pixel location. Texture filtering is a texture stage
//    state that is set using the ITextureStage interface. The values of this
//    enumeration map directly onto the values of the Direct3D enumeration
//    D3DTEXTUREFILTERTYPE. C++ clients can use the Direct3D enumeration
//    directly. This enumeration is defined for the convenience of other
//    languages.
//
// See Also:
//    TextureStageStateType, ITextureStage
enum TextureFilter
{	[helpstring("Help")] SSCLTEXF_NONE = 0,
	[helpstring("Help")] SSCLTEXF_POINT = 1,
	[helpstring("Help")] SSCLTEXF_LINEAR = 2,
	[helpstring("Help")] SSCLTEXF_ANISOTROPIC = 3,
	[helpstring("Help")] SSCLTEXF_FLATCUBIC = 4,
	[helpstring("Help")] SSCLTEXF_GAUSSIANCUBIC = 5
};

[
	helpstring("Texture Addressing Modes"),
	v1_enum
]
// Description:
//    Defines available texture addressing modes.
//
// Remarks:
//    Texture addressing modes determine how texture coordinates are
//    interpreted. The texture addressing mode is a texture stage
//    state that is set using the ITextureStage interface. The values of
//    this enumeration map directly onto the values of the Direct3D
//    enumeration D3DTEXTUREADDRESS. C++ clients can use the Direct3D
//    enumeration directly. This enumeration is defined for the
//    convenience of other languages.
//
// See Also:
//    TextureStageStateType, ITextureStage
enum TextureAddress
{
	[helpstring("Help")] SSCLTADDRESS_WRAP = 1,
	[helpstring("Help")] SSCLTADDRESS_MIRROR = 2,
	[helpstring("Help")] SSCLTADDRESS_CLAMP = 3,
	[helpstring("Help")] SSCLTADDRESS_BORDER = 4,
	[helpstring("Help")] SSCLTADDRESS_MIRRORONCE = 5
};

[
	helpstring("Vertex Fields"),
	v1_enum
]
// Description:
//    Defines the possible data fields that can be found in a vertex.
//
// Remarks:
//    A vertex contains more than just a point in 3D space. This additional
//    information can vary, depending on the type of vertex (see Direct3D
//    documentation on flexible vertex formats). For example, an unlit
//    vertex will contain a normal vector that is used by the rendering
//    engine to calculate lighting for the vertex. A prelit vertex will
//    contain a color value, but not a normal vector. This enumeration
//    provides a way to specify individual fields in a vertex when
//    accessing a mesh.
//
// See Also:
//    IMesh, IMeshEditor
enum VertexField
{
	[helpstring("Position")] SR_VERTEX_POSITION = 0,
	[helpstring("Normal Vector")] SR_VERTEX_NORMAL = 1,
	[helpstring("Texture Coordinates")] SR_VERTEX_TEXTURE_COORDINATE_1 = 2,
	[helpstring("Texture Coordinates")] SR_VERTEX_TEXTURE_COORDINATE_2 = 3,
	[helpstring("Texture Coordinates")] SR_VERTEX_TEXTURE_COORDINATE_3 = 4,
	[helpstring("Texture Coordinates")] SR_VERTEX_TEXTURE_COORDINATE_4 = 5,
	[helpstring("Texture Coordinates")] SR_VERTEX_TEXTURE_COORDINATE_5 = 6,
	[helpstring("Texture Coordinates")] SR_VERTEX_TEXTURE_COORDINATE_6 = 7,
	[helpstring("Texture Coordinates")] SR_VERTEX_TEXTURE_COORDINATE_7 = 8,
	[helpstring("Texture Coordinates")] SR_VERTEX_TEXTURE_COORDINATE_8 = 9,
	[helpstring("Color")] SR_VERTEX_COLOR = 10,
	[helpstring("Specular Color")] SR_VERTEX_SPECULAR = 11
};

[
	helpstring("Vertex Normal Algorithms"),
	v1_enum
]
// Description:
//    Defines algorithms used for calculating vertex normals in a mesh.
//
// Remarks:
//    Used by IMesh::UpdateVertexNormals to specify an algorithm for calculating
//    vertex normals.
//
// See Also:
//    IMesh
enum VertexNormalAlgorithm
{
	[helpstring("Help")] SSCL_NORMAL_PER_FACE = 0,
	[helpstring("Help")] SSCL_NORMAL_BLENDED = 1
};

[
	helpstring("Hit Testing Methods"),
	v1_enum
]
// Description:
//    Defines hit testing strategies for visual objects.
//
// Remarks:
//    A hit testing strategy specifies the method used to perform hit testing.
//    Each hit testing strategy has performance and accuracy tradeoffs.
//
//    SSCL_TEST_BOUNDING_SPHERE   - Fastest technique and least precise
//    SSCL_TEST_BOUNDING_BOX      - More precise than sphere and still pretty fast
//    SSCL_TEST_SOLID_REGION      - Very precise but very slow
//
// See Also:
//    IVisual
enum HitTestStrategy
{
	[helpstring("Help")] SSCL_TEST_BOUNDING_SPHERE = 1,
	[helpstring("Help")] SSCL_TEST_BOUNDING_BOX = 2,
	[helpstring("Help")] SSCL_TEST_SOLID_REGION = 3
};

[
	helpstring("Camera Movements"),
	v1_enum
]
// Description:
//    Defines camera movements.
//
// Remarks:
//    Passed to ICamera::Move to specify a type of camera movement.
//
// See Also:
//    ICamera
enum CameraMovement
{
	[helpstring("Help")] SSCL_CAMERA_UP = 1,
	[helpstring("Help")] SSCL_CAMERA_DOWN = 2,
	[helpstring("Help")] SSCL_CAMERA_LEFT = 3,
	[helpstring("Help")] SSCL_CAMERA_RIGHT = 4,
	[helpstring("Help")] SSCL_CAMERA_FORWARD = 5,
	[helpstring("Help")] SSCL_CAMERA_BACKWARD = 6,
	[helpstring("Help")] SSCL_CAMERA_PITCH_UP = 7,
	[helpstring("Help")] SSCL_CAMERA_PITCH_DOWN = 8,
	[helpstring("Help")] SSCL_CAMERA_YAW_LEFT = 9,
	[helpstring("Help")] SSCL_CAMERA_YAW_RIGHT = 10,
	[helpstring("Help")] SSCL_CAMERA_ROLL_LEFT = 11,
	[helpstring("Help")] SSCL_CAMERA_ROLL_RIGHT = 12,
	[helpstring("Help")] SSCL_CAMERA_LEVEL_XZ = 13,
	[helpstring("Help")] SSCL_CAMERA_GOTO_XAXIS = 14,
	[helpstring("Help")] SSCL_CAMERA_GOTO_YAXIS = 15,
	[helpstring("Help")] SSCL_CAMERA_GOTO_ZAXIS = 16
};

[
	object,
	uuid(80D7A0D4-6D21-479f-BF81-29A20A2F0784),
	dual,
	helpstring("IPropertyContainer Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    This interface provides methods for accessing, adding, and removing
//    properties at run time.
//
// Remarks:
//    This interface extends IDispatch with methods for adding and
//    removing properties at runtime. It also provides "get" and "put"
//    methods that are equivalent to calling Invoke with the
//    DISPATCH_PROPERTYGET and DISPATCH_PROPERTYPUT flags.
////////////////////////////////////////////////////////////////////////////
interface IPropertyContainer : IDispatch
{
	// Description:
	//    Given a property name return the corresponding property ID.
	// Parameters:
	//    PropertyName - Name of property to access
	//    PropertyId   - Output parameter to receive the property ID
	// Return Value:
	//    S_OK               - Named property exists and ID successfully
	//                         returned
	//    DISP_E_UNKNOWNNAME - Invalid property name given
	[id(SSCLID_GET_PROPERTY_ID), helpstring("method GetPropertyId")]
		HRESULT GetPropertyId([in] BSTR PropertyName,
		                      [out,retval] DISPID* PropertyId);

	// Description:
	//    Get the value of a property given a property ID.
	// Parameters:
	//    PropertyId   - ID of property to retrieve
	//    Value        - Output parameter to receive VARIANT value
	// Return Value:
	//    S_OK                  - Property value successfully returned
	//    DISP_E_MEMBERNOTFOUND - Property ID not valid
	//    E_POINTER             - Pointer parameter is NULL or contains
	//                            invalid address
	[id(SSCLID_GET_PROPERTY), helpstring("method GetProperty")]
		HRESULT GetProperty([in] DISPID PropertyId,
		                    [out,retval] VARIANT* Value);

	// Description:
	//    Set the value of a property given a property ID.
	// Parameters:
	//    PropertyId   - ID of property to set
	//    Value        - Input parameter containing new property value
	// Return Value:
	//    S_OK                  - Property value successfully set
	//    DISP_E_MEMBERNOTFOUND - Property ID not valid
	[id(SSCLID_PUT_PROPERTY), helpstring("method PutProperty")]
		HRESULT PutProperty([in] DISPID PropertyId,
		                    [in] VARIANT Value);

	// Description:
	//    Add a new property to the container.
	// Remarks:
	//    If the property already exists, the value is updated.
	// Parameters:
	//    PropertyName  - Name of property
	//    Value         - Input parameter containing new property value
	//    PropertyId    - Output parameter to receive property ID generated
	//                    for the new property
	// Return Value:
	//    S_OK          - Property added successfully
	//    E_FAIL        - Property could not be added; property table full
	[id(SSCLID_ADD_PROPERTY), helpstring("method AddProperty")]
		HRESULT AddProperty([in] BSTR PropertyName,
		                    [in] VARIANT Value,
		                    [out,retval] DISPID* PropertyId);

	// Description:
	//    Remove an existing property from the container.
	// Parameters:
	//    PropertyId   - ID of property to remove
	// Return Value:
	//    S_OK                  - Property value successfully removed
	//    DISP_E_MEMBERNOTFOUND - Property ID not valid
	[id(SSCLID_REMOVE_PROPERTY), helpstring("method RemoveProperty")]
		HRESULT RemoveProperty([in] DISPID PropertyId);
};

[
	object,
	uuid(75CA5413-DF5C-4a50-A2EA-66FA5530A0D2),
	dual,
	helpstring("IDeviceResource Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    This interface provides the mechanism for loading and unloading
//    resources to and from devices.
//
// Remarks:
//    The process of loading a device involves creation of one or
//    more resource objects such as textures, vertex buffers, index
//    buffers, or surfaces. The resources are stored in the device
//    object and associated with a unique resource identifier.
//    Unloading the device frees resources that the object has
//    loaded onto the device.
//
// See Also:
//    IDevice, INode
////////////////////////////////////////////////////////////////////////////
interface IDeviceResource : IPropertyContainer
{
	// Description:
	//    Loads resources needed by the object onto the specified device.
	// Parameters:
	//    Device    - Pointer to device on which resources will be loaded onto
	// Return Value:
	//    S_OK   - Succeeded
	//    E_FAIL - Unable to load
	[id(SSCLID_LOADDEVICE), helpstring("method LoadDevice")]
		HRESULT LoadDevice([in] IDevice* Device);

	// Description:
	//    Frees resources on the specified device used by the object.
	// Parameters:
	//    Device    - Pointer to device to be unloaded
	// Return Value:
	//    S_OK   - Succeeded
	//    E_FAIL - Unable to load
	[id(SSCLID_UNLOADDEVICE), helpstring("method UnloadDevice")]
		HRESULT UnloadDevice([in] IDevice* Device);
};

[
	object,
	uuid(942BE1B2-2183-4fa6-8393-FA6815FCC0E1),
	dual,
	helpstring("INode Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Nodes are named objects that form a hierarchy. All objects that
//    can be placed in a model hierarchy and referenced by name must
//    implement this interface.
//
// Remarks:
//    Each node has a name and a reference to its parent. Names are
//    unique within the scope of the parent - they cannot conflict with
//    any sibling nodes. Fully qualified names are prefixed with the
//    names of all parent nodes, separated by delimiters. The parent
//    names act as a path designation that makes the name unique.
//
// See Also:
//    IDeviceResource, ICompositeNode
////////////////////////////////////////////////////////////////////////////
interface INode : IDeviceResource
{
	// Description:
	//    Refers to the node's parent.
	[propget, id(SSCLID_PARENT), helpstring("property Parent")]
		HRESULT Parent([out, retval] INode** ppVal);

	[propputref, id(SSCLID_PARENT), helpstring("property Parent")]
		HRESULT Parent([in] INode* Parent);

	// Description:
	//    Refers to the root node in the hierarchy.
	// Remarks:
	//    This is a read-only property that recurses from the
	//    node to the root node in the hierarchy.
	[propget, id(SSCLID_ROOT), helpstring("property Root")]
		HRESULT Root([out, retval] INode** ppVal);

	// Description:
	//    Contains the name of the node.
	// Remarks:
	//    The name must be unique within the scope of the node's
	//    parent.
	[propget, id(SSCLID_NAME), helpstring("property Name")]
		HRESULT Name([out, retval] BSTR *pVal);

	[propput, id(SSCLID_NAME), helpstring("property Name")]
		HRESULT Name([in] BSTR newVal);

	// Description:
	//    Fully qualified name of the node.
	// Remarks:
	//    The fullname is prefixed with the names of the node's
	//    ancestors.
	[propget, id(SSCLID_FULLNAME), helpstring("property FullName")]
		HRESULT FullName([out, retval] BSTR *pVal);

	// Description:
	//    The full name of the node relative to the top-level node.
	// Remarks:
	//    This property is useful for getting the name of the node relative
	//    to the top-level node (usually a model). The value returned can be
	//    passed to functions supported by the top-level node such as
	//    ICompositeNode::GetChildByName.
	[propget, id(SSCLID_RELATIVE_PATH), helpstring("property RelativePath")]
		HRESULT RelativePath([out, retval] BSTR *pVal);
};

[
	object,
	uuid(3E5927F1-1F10-496b-AC0C-55E5046541F0),
	dual,
	helpstring("ICompositeNode Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    A composite node is a node that has children.
//
// Remarks:
//    This interface extends the INode interface with methods for
//    adding, removing, and retrieving child nodes.
//
// See Also:
//    INode
////////////////////////////////////////////////////////////////////////////
interface ICompositeNode : INode
{
	// Description:
	//    Return the number of child nodes contained by the node.
	// Parameters:
	//    NumChildren  - Output parameter to receive child count
	// Return Value:
	//    S_OK      - Success
	//    E_POINTER - Pointer parameter is NULL or contains invalid address
	[id(SSCLID_GET_CHILDCOUNT), helpstring("method GetChildCount")]
		HRESULT GetChildCount([out,retval] long* NumChildren);

	// Description:
	//    Lookup a child by name and return its index value.
	// Parameters:
	//    Name       - Name of the child to lookup
	//    ChildIndex - Receives the index value of the child found
	// Return Value:
	//    S_OK       - Child found and index successfully returned
	//    S_FALSE    - Child does not exist
	//    E_POINTER  - Pointer parameter is NULL or contains invalid address
	// Remarks:
	//    Index values for child nodes are zero-based and run from 0
	//    to N-1, where N is the number of child nodes. This function is
	//    not recursive and does not accept compound node names.
	[id(SSCLID_GET_CHILD_INDEX), helpstring("method GetChildIndex")]
		HRESULT GetChildIndex([in] BSTR Name, [out,retval] long* ChildIndex);

	// Description:
	//    Retrieve a child node using an index value.
	// Parameters:
	//    Child   - Output parameter to receive child retrieved
	// Return Value:
	//    S_OK      - Success
	//    E_FAIL    - Index is out of range
	//    E_POINTER - Pointer parameter is NULL or contains invalid address
	[id(SSCLID_GET_CHILD), helpstring("method GetChild")]
		HRESULT GetChild([in] long ChildIndex, [out,retval] INode** Child);

	// Description:
	//    Retrieve a child node by name
	// Parameters:
	//    Name   - Name of child to retrieve
	// Return Value:
	//    S_OK      - Child found and returned successfully
	//    S_FALSE   - Child does not exist
	//    E_POINTER - Pointer parameter is NULL or contains invalid address
	// Remarks:
	//    The node name can include a path that will cause the search to
	//    go several levels deeper. For example, the name
	//    "Truck.RearAxle.Wheel.LugNut" would do a recursive search starting
	//    with this node and will return a child node 3 levels deep named
	//    "LugNut".
	[id(SSCLID_GET_CHILDBYNAME), helpstring("method GetChildByName")]
		HRESULT GetChildByName([in] BSTR Name, [out,retval] INode** Node);

	// Description:
	//    Append a child node to the back of the list.
	// Parameters:
	//    Child   - Child node to append
	// Return Value:
	//    S_OK    - Child appended successfully
	//    E_FAIL  - Unexpected error occurred
	[id(SSCLID_APPEND_CHILD), helpstring("method AppendChild")]
		HRESULT AppendChild([in] INode* Child);

	// Description:
	//    Insert a child node at a given spot in the list.
	// Parameters:
	//    Child      - Child node to insert
	//    ChildIndex - Ordinal position at which to insert the child node
	//                 (zero-based)
	// Return Value:
	//    S_OK       - Child inserted successfully
	//    E_FAIL     - Index value is invalid or unexpected error occurred
	// Remarks:
	//    If successful, the index value of the new child node will be the
	//    same as the index value passed in.
	[id(SSCLID_INSERT_CHILD), helpstring("method InsertChild")]
		HRESULT InsertChild([in] INode* Child, [in] long ChildIndex);

	// Description:
	//    Remove a child node.
	// Parameters:
	//    Child     - Child node to remove
	// Return Value:
	//    S_OK      - Child successfully removed
	//    S_FALSE   - Child not found
	//    E_FAIL    - Unexpected error occurred
	[id(SSCLID_REMOVE_CHILD), helpstring("method RemoveChild")]
		HRESULT RemoveChild([in] INode* Child);

	// Description:
	//    Removes all child nodes.
	// Return Value:
	//    S_OK    - Success
	// Remarks:
	//    This function removes all children from the given node.
	[id(SSCLID_REMOVE_ALLCHILDREN), helpstring("method RemoveAllChildren")]
		HRESULT RemoveAllChildren();

	// Description:
	//    This function is called by the framework to notify parents of changes
	//    that occur in child nodes.
	// Parameters:
	//    Node       - Pointer to child node that has changed
	//    NotifyCode - Code indicating the type of update that has occurred
	[id(SSCLID_ON_CHILD_UPDATE), helpstring("method OnChildUpdate")]
		HRESULT OnChildUpdate([in] INode* Node, [in] long NotifyCode);
};

[
	object,
	uuid(89018219-1BA7-468f-ACCD-FFCEB9DFAC78),
	dual,
	helpstring("IXMLArchive Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    XML archives provide an interface for serializing objects and their
//    contents to and from the XML DOM.
//
// Remarks:
//    An XML archive is essentially a wrapper around the XML DOM that
//    provides navigation and object reference tracking.
//
// See Also:
//    IPersistXML
////////////////////////////////////////////////////////////////////////////
interface IXMLArchive : IDispatch
{
	// Description:
	//    Get a pointer to the XML DOM.
	[propget, id(SSCLID_DOM_DOCUMENT), helpstring("property DOMDocument")]
		HRESULT DOMDocument([out, retval] IXMLDOMDocument** ppVal);

	// Description:
	//    Get and set the pointer to the current DOM node.
	[propget, id(SSCLID_CURRENT_NODE), helpstring("property CurrentNode")]
		HRESULT CurrentNode([out, retval] IXMLDOMNode** ppVal);

	[propputref, id(SSCLID_CURRENT_NODE), helpstring("property CurrentNode")]
		HRESULT CurrentNode([in] IXMLDOMNode* pNewVal);

	// Description:
	//    Get and set the namespace used for elements in the document.
	[propget, id(SSCLID_NAMESPACE), helpstring("property Namespace")]
		HRESULT Namespace([out, retval] BSTR* pVal);

	[propput, id(SSCLID_NAMESPACE), helpstring("property Namespace")]
		HRESULT Namespace([in] BSTR newVal);

	// Description:
	//    Parse a document into the DOM.
	[id(SSCLID_LOAD), helpstring("method Load")]
		HRESULT Load([in] VARIANT Source);

	// Description:
	//    Save the document out to a file.
	[id(SSCLID_SAVE), helpstring("method Save")]
		HRESULT Save([in] VARIANT Destination);

	// Description:
	//    Remove all nodes from the DOM and reinitialize all archive settings.
	[id(SSCLID_CLEAR), helpstring("method Clear")]
		HRESULT Clear();

	// Description:
	//    Create a new element in the document.
	[id(SSCLID_CREATEELEMENT), helpstring("method CreateElement")]
		HRESULT CreateElement([in] BSTR Tag);

	// Description:
	//    Go to a given node in the document using XPath syntax.
	[id(SSCLID_GOTO_NODE), helpstring("method GotoNode")]
		HRESULT GotoNode([in] BSTR XPath);

	// Description:
	//    Go to a given node given an ID.
	[id(SSCLID_GOTO_NODEBYID), helpstring("method GotoNodeByID")]
		HRESULT GotoNodeByID([in] BSTR NodeID);

	// Description:
	//    Go to the first child node of the current node.
	[id(SSCLID_GOTO_FIRSTCHILD), helpstring("method GotoFirstChild")]
		HRESULT GotoFirstChild();

	// Description:
	//    Go to the next sibling node of the current node.
	[id(SSCLID_GOTO_NEXTSIBLING), helpstring("method GotoNextSibling")]
		HRESULT GotoNextSibling();

	// Description:
	//    Go to the previous sibling node of the current node.
	[id(SSCLID_GOTO_PREVIOUSSIBLING), helpstring("method GotoPreviousSibling")]
		HRESULT GotoPreviousSibling();

	// Description:
	//    Go to the parent node of the current node.
	[id(SSCLID_GOTO_PARENT), helpstring("method GotoParent")]
		HRESULT GotoParent();

	// Description:
	//    Test the current tag for equality against a given value.
	[id(SSCLID_COMPARECURRENTTAG), helpstring("method CompareCurrentTag")]
		HRESULT CompareCurrentTag([in] BSTR Tag);

	// Description:
	//    Takes a snapshot of the current state of the XML archive and returns
	//    a handle that can be used to restore the state.
	[id(SSCLID_GET_CONTEXT), helpstring("method GetContext")]
		HRESULT GetContext([out,retval] long* ContextHandle);

	// Description:
	//    Restores the XML archive to a saved state.
	[id(SSCLID_SET_CONTEXT), helpstring("method SetContext")]
		HRESULT SetContext([in] long ContextHandle);

	// Description:
	//    Restores the XML archive to a saved state.
	[id(SSCLID_FREECONTEXT), helpstring("method FreeContext")]
		HRESULT FreeContext([in] long ContextHandle);

	// Description:
	//    Read the current element value.
	[id(SSCLID_READELEMENT), helpstring("method ReadElement")]
		HRESULT ReadElement([in] VARTYPE DataType, [out,retval] VARIANT* Value);

	// Description:
	//    Write the current element value.
	[id(SSCLID_WRITEELEMENT), helpstring("method WriteElement")]
		HRESULT WriteElement([in] VARIANT Value, [in] BSTR Format);

	// Description:
	//    Read a given attribute from the current node.
	[id(SSCLID_READATTRIBUTE), helpstring("method ReadAttribute")]
		HRESULT ReadAttribute([in] BSTR strTag, [out,retval] VARIANT* pValue);

	// Description:
	//    Write a given attribute from the current node.
	[id(SSCLID_WRITEATTRIBUTE), helpstring("method WriteAttribute")]
		HRESULT WriteAttribute([in] BSTR strTag, [in] VARIANT varValue);

	// Description:
	//    Read the current node as an object.
	[id(SSCLID_READOBJECT), helpstring("method ReadObject")]
		HRESULT ReadObject([out,retval] IUnknown** Obj);

	// Description:
	//    Write the given object to the current node.
	[id(SSCLID_WRITEOBJECT), helpstring("method WriteObject")]
		HRESULT WriteObject([in] IUnknown* Obj);

	// Description:
	//    Read object by value from the current node.
	[id(SSCLID_READOBJECTVALUE), helpstring("method ReadObjectValue")]
		HRESULT ReadObjectValue([out,retval] IUnknown** Obj);

	// Description:
	//    Write object by value to the current node.
	[id(SSCLID_WRITEOBJECTVALUE), helpstring("method WriteObjectValue")]
		HRESULT WriteObjectValue([in] IUnknown* Obj);

	// Description:
	//    Read object reference from the current node.
	[id(SSCLID_READOBJECTREFERENCE), helpstring("method ReadObjectReference")]
		HRESULT ReadObjectReference([out,retval] IUnknown** Obj);

	// Description:
	//    Write object reference to the current node.
	[id(SSCLID_WRITEOBJECTREFERENCE), helpstring("method WriteObjectReference")]
		HRESULT WriteObjectReference([in] IUnknown* Obj);
};

[
	object,
	uuid(C0483EBC-C8D8-4352-80CB-DC9DE9F3BB53),
	helpstring("IPersistXML Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Interface to objects that support XML serialization.
//
// Remarks:
//    This interface provides methods for loading and saving the
//    contents of an object to and from XML. Objects that implement
//    this interface load and save their contents to and from an XML
//    archive object.
//
// See Also:
//    IXMLArchive
////////////////////////////////////////////////////////////////////////////
interface IPersistXML : IPersist
{
	// Description:
	//    Get the element tag associated with the object.
	// Parameters:
	//    Tag  - Output parameter to receive XML tag associated with
	//           this object.
	// Return Value:
	//    S_OK   - Always succeeds
	HRESULT GetTag([out,retval] BSTR* Tag);

	// Description:
	//    Get the object's unique ID.
	// Parameters:
	//    ObjectID  - Output parameter to receive the unique ID
	//                associated with this object. If the object is
	//                a node, the ID is the fully qualified name of
	//                the node.
	// Return Value:
	//    S_OK      - Successful
	//    S_FALSE   - Object has no ID and the string returned is empty
	HRESULT GetObjectID([out,retval] BSTR* ObjectID);

	// Description:
	//    Load the object from a given XML archive.
	// Parameters:
	//    Archive  - Archive to load object from
	// Return Value:
	//    S_OK   - Object successfully loaded
	//    E_FAIL - Error occurred during loading
	// Remarks:
	//    When this function is called, the archive must be positioned
	//    to the XML DOM node that contains the object.
	// See also:
	//    IXMLArchive
	HRESULT LoadXML([in] IXMLArchive* Archive);

	// Description:
	//    Save the object to a given XML archive.
	// Parameters:
	//    Archive  - Archive to save object to
	// Return Value:
	//    S_OK   - Object successfully loaded
	//    E_FAIL - Error occurred during save
	// Remarks:
	//    When this function is called, the archive must be positioned
	//    to the XML DOM node that will be written.
	// See also:
	//    IXMLArchive
	HRESULT SaveXML([in] IXMLArchive* Archive);
};

[
	object,
	uuid(6B3684F3-99EF-4319-B9A6-BE399D90D6CE),
	helpstring("IWndMessageReceiver Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    This interface provides a way for objects to listen for window
//    messages. Objects that implement this interface can be attached
//    to window message sources and receive messages.
//
// Remarks:
//    Controllers and behaviors are examples of window message receivers.
//
// See Also:
//    IWndMessageSource
////////////////////////////////////////////////////////////////////////////
interface IWndMessageReceiver : IUnknown
{
	// Description:
	//    Called by a message source object to forward messages to the receiver.
	HRESULT ProcessWindowMessage([in] UINT uMsg, [in] WPARAM wParam, [in] LPARAM lParam);
};

[
	object,
	uuid(79166C87-6D9C-487a-B6D1-1663E8D7B3D5),
	dual,
	helpstring("IWndMessageSource Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Interface to objects that generate window messages.
//
// Remarks:
//    This interface is implemented by objects that generate or forward
//    window messages to message receivers (i.e. listeners). A window
//    message source object is connected to a window and sends the
//    messages from that window onto receivers that are listening.
//
// See Also:
//    IWndMessageReceiver
////////////////////////////////////////////////////////////////////////////
interface IWndMessageSource : IDispatch
{
	// Description:
	//    Connects the message source object to a window.
	// Parameters:
	//    WindowHandle  - Handle of window to intercept messages from
	// Return Value:
	//    S_OK   - Successful
	//    E_FAIL - Not a valid window handle
	// Remarks:
	//    This method subclasses the window and forwards messages to
	//    the message receivers that subscribe to this message source.
	//    Messages are also sent to the original window procedure
	//    associated with the window.
	[id(SSCLID_CONNECT), helpstring("method Connect")]
		HRESULT Connect([in] long WindowHandle);

	// Description:
	//    Disconnects the message source object from the window.
	// Return Value:
	//    S_OK   - Successful
	//    E_FAIL - Not currently connected to a valid window
	// Remarks:
	//    This method restores the original window procedure
	[id(SSCLID_DISCONNECT), helpstring("method Disconnect")]
		HRESULT Disconnect();

	// Description:
	//    Adds a message receiver
	// Return Value:
	//    S_OK   - Successful
	//    E_FAIL - Unexpected error occurred
	// Remarks:
	//    Message receivers subscribe to the events intercepted
	//    by the message source.
	[id(SSCLID_ADD_RECEIVER), helpstring("method AddReceiver")]
		HRESULT AddReceiver([in] IUnknown* Receiver);

	// Description:
	//    Removes a message receiver
	// Return Value:
	//    S_OK   - Successful
	//    E_FAIL - Unexpected error occurred
	// Remarks:
	//    Message receivers subscribe to the events intercepted
	//    by the message source.
	[id(SSCLID_REMOVE_RECEIVER), helpstring("method RemoveReceiver")]
		HRESULT RemoveReceiver([in] IUnknown* Receiver);

	// Description:
	//    Sends a message to the receivers that subscribe to this message source
	// Return Value:
	//    S_OK   - Successful
	HRESULT SendWindowMessage([in] UINT uMsg, [in] WPARAM wParam, [in] LPARAM lParam);
};

[
	object,
	uuid(C3920845-52CD-4fc1-9190-8BDDF7BA478A),
	dual,
	helpstring("IDevice Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Interface to a rendering device.
//
// Remarks:
//    A device encapsulates information about a video adapter and
//    device driver. One or more viewports are created on a device for
//    rendering to the screen.
//
// See Also:
//    IEngine, IViewport
////////////////////////////////////////////////////////////////////////////
interface IDevice : IDispatch
{
	// Description:
	//    Used for internal initialization of the object by the framework.
	//    DO NOT CALL THIS METHOD DIRECTLY.
	[id(SSCLID_INITOBJECT), hidden, helpstring("property _InitObject")]
		HRESULT _InitObject([in] IEngine* Engine, [in] short DeviceIdx);

	// Description:
	//    Initializes the device and prepares it to be used for rendering.
	// Parameters:
	//    FocusWnd - Window handle to which focus belongs for this device.
	// Remarks:
	//    This method creates the underlying Direct3D device object. It
	//    also creates any depth stencils and back buffers needed by the
	//    device and its associated viewports.
	[id(SSCLID_INITIALIZE), helpstring("method Initialize")]
		HRESULT Initialize([in] long FocusWnd);

	// Description:
	//    Returns a pointer to the underlying Direct3D device object.
	// Parameters:
	//    ppUnk  - Output parameter to receive pointer to the D3D device
	// Remarks:
	//    Returned as a pointer to IUnknown for flexibility. Caller
	//    must call QueryInterface to the interface they need
	[id(SSCLID_GET_D3DDEVICE), helpstring("method GetD3DDevice")]
		HRESULT GetD3DDevice([out,retval] IUnknown** ppUnk);

	// Description:
	//    Create a viewport onto the device.
	// Parameters:
	//    ProgId     - Program ID of viewport class or NULL for default
	//                 viewport type.
	//    ppViewport - Output parameter that receives the pointer to the
	//                 new viewport.
	// Remarks:
	//    The ProgId parameter can be used to create any object that
	//    supports the IViewport interface. If it is not specified, then
	//    the default Viewport class is created. The viewport is
	//    associated with the device for its lifetime.
	[id(SSCLID_CREATE_VIEWPORT), helpstring("method CreateViewport")]
		HRESULT CreateViewport([in] VARIANT ProgId,
			                   [out,retval] IViewport** ppViewport);

	// Description:
	//    Returns the number of display modes supported by the adapter.
	// Parameters:
	//    NumModes  - Output parameter that receives the results
	// Remarks:
	//    The number of display modes supported depends on the type
	//    of adapter and amount of video memory.
	[id(SSCLID_GET_DISPLAYMODECOUNT), helpstring("method GetDisplayModeCount")]
		HRESULT GetDisplayModeCount([out,retval] short* NumModes);

	// Description:
	//    Returns display mode info given an ordinal value.
	// Parameters:
	//    ModeIdx      - Ordinal value that specifies the mode (zero based)
	//    DispModeInfo - Output parameter that receives a DISPLAYMODEINFO
	//                   structure
	// Remarks:
	//    Each display mode support by the adapter is identified by an
	//    ordinal number (0 - number of modes)
	[id(SSCLID_GET_DISPLAYMODEINFO), helpstring("method GetDisplayMode")]
		HRESULT GetDisplayModeInfo([in] short ModeIdx,
		                           [out,retval] VARIANT* DispModeInfo);

	// Description:
	//    Returns the device object class ID.
	// Parameters:
	//    DeviceGuid  - Output parameter to receive GUID
	HRESULT GetDeviceGUID([out] GUID* DeviceGuid);

	// Description:
	//    Returns a handle for the monitor attached to the adapter.
	// Parameters:
	//    MonitorHandle  - Output parameter to receive monitor handle
	HRESULT GetMonitor([out] long* MonitorHandle);

	// Description:
	//    Display mode used by this device object.
	// Remarks:
	//    This value is an index into the valid display modes supported by
	//    the device.
	// See Also:
	//    GetDisplayModeCount, GetDisplayModeInfo
	[propget, id(SSCLID_DISPLAY_MODE), helpstring("property DisplayMode")]
		HRESULT DisplayMode([out,retval] short *pVal);

	[propput, id(SSCLID_DISPLAY_MODE), helpstring("property DisplayMode")]
		HRESULT DisplayMode([in] short newVal);

	// Description:
	//    Device driver mode used to access the hardware.
	// See Also:
	//    enum DriverMode
	[propget, id(SSCLID_DRIVERMODE), helpstring("property DriverMode")]
		HRESULT DriverMode([out,retval] enum DriverMode *Mode);

	[propput, id(SSCLID_DRIVERMODE), helpstring("property DriverMode")]
		HRESULT DriverMode([in] enum DriverMode Mode);

	// Description:
	//    Focus window associated with the device.
	[propget, id(SSCLID_FOCUS_WINDOW), helpstring("property FocusWindow")]
		HRESULT FocusWindow([out,retval] long *pVal);

	// Description:
	//    Device driver name for the adapter.
	[propget, id(SSCLID_DRIVERNAME), helpstring("property DriverName")]
		HRESULT DriverName([out,retval] BSTR *pVal);

	// Description:
	//    Description of the device driver.
	[propget, id(SSCLID_DRIVERDESC), helpstring("property DriverDesc")]
		HRESULT DriverDesc([out,retval] BSTR *pVal);

	// Description:
	//    Product name of the adapter.
	[propget, id(SSCLID_PRODUCT), helpstring("property Product")]
		HRESULT Product([out,retval] long *pVal);

	// Description:
	//    Device driver version number.
	[propget, id(SSCLID_VERSION), helpstring("property Version")]
		HRESULT Version([out,retval] long *pVal);

	// Description:
	//    Device driver sub-version number.
	[propget, id(SSCLID_SUBVERSION), helpstring("property SubVersion")]
		HRESULT SubVersion([out,retval] long *pVal);

	// Description:
	//    Device driver build number.
	[propget, id(SSCLID_BUILD), helpstring("property Build")]
		HRESULT Build([out,retval] long *pVal);

	// Description:
	//    Manufacturer of adapter used help to identify the adapter chip set.
	// Remarks:
	//    May be zero if unknown.
	[propget, id(SSCLID_VENDORID), helpstring("property VendorId")]
		HRESULT VendorId([out,retval] long *pVal);

	// Description:
	//    Device ID used to help identify the adapter chip set.
	// Remarks:
	//    May be zero if unknown.
	[propget, id(SSCLID_DEVICEID), helpstring("property DeviceId")]
		HRESULT DeviceId([out,retval] long *pVal);

	// Description:
	//    Subsystem ID used to help identify a particular chip set.
	// Remarks:
	//    This value typically indicates the particular board. The value may
	//    be zero if unknown. 
	[propget, id(SSCLID_SUBSYSID), helpstring("property SubsysId")]
		HRESULT SubsysId([out,retval] long *pVal);

	// Description:
	//    Revision number of the driver.
	[propget, id(SSCLID_REVISION), helpstring("property Revision")]
		HRESULT Revision([out,retval] long *pVal);

	// Description:
	//    Windows Hardware Quality Lab certification level for the driver.
	[propget, id(SSCLID_WHQL_LEVEL), helpstring("property WHQLLevel")]
		HRESULT WHQLLevel([out,retval] long *pVal);
};

[
	object,
	uuid(A5618878-3095-4edb-A632-88C64ED7A1C5),
	dual,
	helpstring("IInputDevice Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Interface to an input device.
//
// Remarks:
//    An input device belongs to one category. Input devices are attached
//    to controllers to provide input to the controller.
//
// See Also:
//    InputDeviceCategory, IController
////////////////////////////////////////////////////////////////////////////
interface IInputDevice : IDispatch
{
	[id(SSCLID_GET_DIDEVICE), helpstring("method GetDIDevice")]
		HRESULT GetDIDevice([out,retval] IUnknown** DIDevice);

	// Description:
	//    Defines the input device category this device belongs to
	[propget, id(SSCLID_DEVICE_CATEGORY), helpstring("property DeviceCategory")]
		HRESULT DeviceCategory([out,retval] enum InputDeviceCategory *pVal);

	// Description:
	//    Maps to DIDEVICEINSTANCE.dwDevType
	[propget, id(SSCLID_DEVICE_TYPE), helpstring("property DeviceType")]
		HRESULT DeviceType([out,retval] long *pVal);

	// Description:
	//    Maps to DIDEVICEINSTANCE.tszInstanceName
	[propget, id(SSCLID_DEVICE_NAME), helpstring("property DeviceName")]
		HRESULT DeviceName([out,retval] BSTR *pVal);

	// Description:
	//    Maps to DIDEVICEINSTANCE.tszProductName
	[propget, id(SSCLID_PRODUCT_NAME), helpstring("property ProductName")]
		HRESULT ProductName([out,retval] BSTR *pVal);

	// Description:
	//    Maps to DIDEVCAPS.dwAxes
	[propget, id(SSCLID_AXES), helpstring("property Axes")]
		HRESULT Axes([out,retval] short *pVal);

	// Description:
	//    Maps to DIDEVCAPS.dwButtons
	[propget, id(SSCLID_BUTTONS), helpstring("property Buttons")]
		HRESULT Buttons([out,retval] short *pVal);

	// Description:
	//    Maps to DIDEVCAPS.dwPOVs
	[propget, id(SSCLID_POVS), helpstring("property POVs")]
		HRESULT POVs([out,retval] short *pVal);

	// Description:
	//    Maps to DIDEVCAPS.dwFFSamplePeriod
	[propget, id(SSCLID_FF_SAMPLE_PERIOD), helpstring("property FFSamplePeriod")]
		HRESULT FFSamplePeriod([out,retval] long *pVal);

	// Description:
	//    Maps to DIDEVCAPS.dwFFMinTimeResolution
	[propget, id(SSCLID_FF_MIN_TIME_RESOLUTION), helpstring("property FFMinTimeResolution")]
		HRESULT FFMinTimeResolution([out,retval] long *pVal);
};

[
	object,
	uuid(B1F687AE-5FBF-4597-B4DE-C280669D725B),
	dual,
	helpstring("IMeasurementScale Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Interface to a measurement scale that is used to convert between
//    logical units and real world measurements.
//
// Remarks:
//    A measurement scale defines a ratio of real world units
//    to logical units.

// See Also:
//    IModel, UnitOfMeasure
////////////////////////////////////////////////////////////////////////////
interface IMeasurementScale : IDispatch
{
	// Description:
	//    Number of logical units per unit measure.
	// Remarks:
	//    Helps to define the ratio of real world units to logical units.
	[propget, id(SSCLID_LOGICALUNITS), helpstring("property LogicalUnits")]
		HRESULT LogicalUnits([out, retval] VALUE3D *pVal);

	[propput, id(SSCLID_LOGICALUNITS), helpstring("property LogicalUnits")]
		HRESULT LogicalUnits([in] VALUE3D newVal);

	// Description:
	//    Real world unit of measure.
	// See Also:
	//    enum UnitOfMeasure.
	[propget, id(SSCLID_UNIT_OF_MEASURE), helpstring("property UnitOfMeasure")]
		HRESULT UnitOfMeasure([out, retval] enum UnitOfMeasure *pVal);

	[propput, id(SSCLID_UNIT_OF_MEASURE), helpstring("property UnitOfMeasure")]
		HRESULT UnitOfMeasure([in] enum UnitOfMeasure newVal);

	// Description:
	//    Number of real world units per logical unit.
	// Remarks:
	//    Helps to define the ratio of real world units to logical units.
	[propget, id(SSCLID_MEASUREMENT), helpstring("property Measurement")]
		HRESULT Measurement([out, retval] double *pVal);

	[propput, id(SSCLID_MEASUREMENT), helpstring("property Measurement")]
		HRESULT Measurement([in] double newVal);

	// Description:
	//    Converts a real world measurement into logical units.
	// Parameters:
	//    Units        - Unit of measurement of the input value
	//    InputVal     - Measurement to convert
	//    pVal         - Output parameter to receive the result of the conversion
	// Return Value:
	//    S_OK   - Successful
	[id(SSCLID_CONVERTMEASUREMENT), helpstring("method ConvertMeasurement")]
		HRESULT ConvertMeasurement([in] enum UnitOfMeasure Units,
			                       [in] double InputVal,
			                       [out,retval] VALUE3D* pVal);

	// Description:
	//    Converts logical units into a real world measurement.
	// Parameters:
	//    LogicalUnits  - Input value to convert
	//    Units         - Unit of measurement of result value
	//    pVal          - Output parameter to receive the result of the conversion
	// Return Value:
	//    S_OK   - Successful
	[id(SSCLID_CONVERTLOGICALUNITS), helpstring("method ConvertLogicalUnits")]
		HRESULT ConvertLogicalUnits([in] VALUE3D LogicalUnits,
			                        [in] enum UnitOfMeasure Units,
			                        [out,retval] double* pVal);
};

[
	object,
	uuid(2C75E383-89BE-4c47-B41C-68DED764ADA3),
	helpstring("IEnumNodes Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Enumerator used to iterate over a collection of nodes.
//
// Remarks:
//    Follows the COM IEnumXXX interface standard so that VB recognizes
//    it.
//
// See Also:
//    INodes
////////////////////////////////////////////////////////////////////////////
interface IEnumNodes : IUnknown
{
	[id(1), helpstring("method Next")]
		HRESULT Next([in] ULONG ItemsRequested,
			         [out, size_is(ItemsRequested,1), length_is(*ItemsReturned,1)] INode** Node,
			         [out] ULONG* ItemsReturned);

	[id(2), helpstring("method Skip")]
		HRESULT Skip([in] ULONG ItemCount);

	[id(3), helpstring("method Reset")]
		HRESULT Reset();

	[id(4), helpstring("method Clone")]
		HRESULT Clone([out] IEnumNodes** ppEnum);
};

[
	object,
	uuid(78B24F94-19C7-41da-8222-7AE8D5850094),
	dual,
	helpstring("INodes Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Interface to a collection of nodes.
//
// Remarks:
//    Any type of node can be put into a node collection. The Enumerators
//    EnumNodeList and EnumVariantNodeList can be used to iterator over
//    the collection. There are also functions to sort the list based on
//    distance from a given point.
//
// See Also:
//    IEnumNodes, NodeList
////////////////////////////////////////////////////////////////////////////
interface INodes : IDispatch
{
	// Description:
	//    Returns the number of nodes in the collection.
	[propget, id(1)]
		HRESULT Count([out,retval] long* ItemCount);

	// Description:
	//    Returns the node in the collection with the given index value.
	[propget, id(DISPID_VALUE)]
		HRESULT Item([in] long Index, [out,retval] INode** Node);

	// Description:
	//    Creates an enumerator for iterating over the collection.
	[propget, id(DISPID_NEWENUM), restricted]
		HRESULT _NewEnum([out,retval] LPUNKNOWN* ppEnum);

	// Description:
	//    Creates an enumerator for iterating over the collection.
	[propget, id(SSCLID_NODE_ENUM), restricted]
		HRESULT _NewNodeEnum([out,retval] LPUNKNOWN* ppEnum);

	// Description:
	//    Removes all nodes from the collection.
	[id(SSCLID_CLEAR), helpstring("method Clear")]
		HRESULT Clear();

	// Description:
	//    Appends a node to the collection.
	// Parameters:
	//    Node   - Pointer to node to add
	[id(SSCLID_ADD), helpstring("method Add")]
		HRESULT Add([in] INode* Node);

	// Description:
	//    Performs a depth sort on the collection.
	//
	// Remarks:
	//    Nodes are sorted based on their distance from the given point. Nodes
	//    nearest to the point are put in the front of the list and nodes farthest
	//    from the point are put in the back of the list.
	//
	// Parameters:
	//    Point    - POINT3D structure that serves as the reference point
	//               for the sort.
	//
	// Return Value:
	//    S_OK     - Sort succeeded
	[id(SSCLID_SORT_BY_DISTANCE), helpstring("method SortByDistance")]
		HRESULT SortByDistance([in] VARIANT Point);

	// Description:
	//    Searches the list for the node closest to the given point that matches
	//    the given style mask.
	//
	// Remarks:
	//    This function is used primarily for hit testing. Only nodes that have
	//    the given style flags turned on are considered.
	//
	// Parameters:
	//    Point     - POINT3D structure containing the point used for the hit test
	//    StyleMask - Used to mask out certain nodes from the test
	//    Node      - Output parameter that receives the node found
	//
	// Return Value:
	//    S_OK      - A matching node was found in the collection and has been
	//                returned to the caller in the output parameter
	//    S_FALSE   - No matching node was found
	//    E_POINTER - Pointer parameter is NULL or contains invalid address
	[id(SSCLID_GET_NEAREST_NODE), helpstring("method GetNearestNode")]
		HRESULT GetNearestNode([in] VARIANT Point,
		                       [in] long StyleMask,
		                       [out,retval] INode** Node);

	// Description:
	//    Tests to see if the collection contains the given node.
	// Parameters:
	//    Node   - Pointer to node to search for.
	// Return Value:
	//    S_OK    - Collection contains the given node
	//    S_FALSE - Node is not in the collection
	[id(SSCLID_CONTAINS_NODE), helpstring("method ContainsNode")]
		HRESULT ContainsNode([in] INode* Node);
};

[
	object,
	uuid(F6DD017E-24C4-4d70-A38B-B2FA1C614ECA),
	dual,
	helpstring("IVisual Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Interface to objects that can be rendered in a 3D model.
//
// Remarks:
//    A visual has dimensions in world space and can be moved, rotated,
//    or scaled.
//
//    Style flags determine the actions that can be performed on a
//    visual object. The SetStyleFlags and TestStyleFlags functions
//    provide access to the style flags. Style flags can be added
//    together using bitwise AND operations. The possible style flag
//    values are listed below:
//
//       * NONE               = 0x00000000;
//       * ALLOW_SELECT       = 0x00000001;
//       * ALLOW_MOVE         = 0x00000002;
//       * ALLOW_ROTATE       = 0x00000004;
//       * ALLOW_SCALE        = 0x00000008;
//       * ALLOW_DELETE       = 0x00000010;
//       * SOLID              = 0x00000020;
//       * ALLOW_BSPTREE      = 0x00000040;
//       * ALL                = 0xFFFFFFFF;
//
// See Also:
//    ICompositeNode
////////////////////////////////////////////////////////////////////////////
interface IVisual : ICompositeNode
{
	// Description:
	//    Indicates whether the visual object is currently visible.
	[propget, id(SSCLID_VISIBLE), helpstring("property Visible")]
		HRESULT Visible([out,retval] VARIANT_BOOL* pVal);

	[propput, id(SSCLID_VISIBLE), helpstring("property Visible")]
		HRESULT Visible([in] VARIANT_BOOL newVal);

	// Description:
	//    Left side of bounding box.
	[propget, id(SSCLID_LEFT), helpstring("property Left")]
		HRESULT Left([out,retval] VALUE3D* pVal);

	// Description:
	//    Right side of bounding box.
	[propget, id(SSCLID_RIGHT), helpstring("property Right")]
		HRESULT Right([out,retval] VALUE3D* pVal);

	// Description:
	//    Top of bounding box.
	[propget, id(SSCLID_TOP), helpstring("property Top")]
		HRESULT Top([out,retval] VALUE3D* pVal);

	// Description:
	//    Bottom of bounding box.
	[propget, id(SSCLID_BOTTOM), helpstring("property Bottom")]
		HRESULT Bottom([out,retval] VALUE3D* pVal);

	// Description:
	//    Front of bounding box.
	[propget, id(SSCLID_FRONT), helpstring("property Front")]
		HRESULT Front([out,retval] VALUE3D* pVal);

	// Description:
	//    Back of bounding box.
	[propget, id(SSCLID_BACK), helpstring("property Back")]
		HRESULT Back([out,retval] VALUE3D* pVal);

	// Description:
	//    X component of the center of the bounding sphere.
	[propget, id(SSCLID_ORIGIN_X), helpstring("property OriginX")]
		HRESULT OriginX([out,retval] VALUE3D* pVal);

	// Description:
	//    Y component of the center of the bounding sphere.
	[propget, id(SSCLID_ORIGIN_Y), helpstring("property OriginY")]
		HRESULT OriginY([out,retval] VALUE3D* pVal);

	// Description:
	//    Z component of the center of the bounding sphere.
	[propget, id(SSCLID_ORIGIN_Z), helpstring("property OriginZ")]
		HRESULT OriginZ([out,retval] VALUE3D* pVal);

	// Description:
	//    Radius of the bounding sphere.
	[propget, id(SSCLID_RADIUS), helpstring("property Radius")]
		HRESULT Radius([out,retval] VALUE3D* pVal);

	// Description:
	//    Push the node's transformation matrix onto the global
	//    transform stack.
	//
	// Remarks:
	//    Each visual node has a transformation matrix that is used
	//    to move, rotate, and scale the node. The transformations
	//    are relative to the node's parent. The transform stack is
	//    used to combine the transformations of a node with those
	//    of its parents in order to produce a final transformation
	//    matrix that positions the node in world space. This function
	//    combines (matrix multiply) the transformation matrix of the
	//    node with the transformation matrix on the top of the stack
	//    and then pushes the resulting matrix on the stack.
	//
	// Return Value:
	//    Always returns S_OK;
	[id(SSCLID_PUSH_TRANSFORM), helpstring("method PushTransform")]
		HRESULT PushTransform();

	// Description:
	//    Pop the global transform stack.
	[id(SSCLID_POP_TRANSFORM), helpstring("method PopTransform")]
		HRESULT PopTransform();

	// Description:
	//    Returns the center of the object's bounding sphere.
	//
	// Remarks:
	//    This function is equivalent to getting the OriginX, OriginY, and
	//    OriginZ properties.
	//
	// Parameters:
	//    Point   - Output parameter to receive a POINT3D structure
	//
	// Return Value:
	//    S_OK    - Succeeded
	[id(SSCLID_GET_ORIGIN), helpstring("method GetOrigin")]
		HRESULT GetOrigin([out,retval] VARIANT* Point);

	// Description:
	//    Returns the object's bounding box.
	//
	// Remarks:
	//    This function is equivalent to getting the Left, Right, Top,
	//    Bottom, Front, and Back properties.
	//
	// Parameters:
	//    Box   - Output parameter to receive a BOX3D structure
	//
	// Return Value:
	//    S_OK    - Succeeded
	[id(SSCLID_GET_BOUNDINGBOX), helpstring("method GetBoundingBox")]
		HRESULT GetBoundingBox([out,retval] VARIANT* Box);

	// Description:
	//    Sets the object's bounding box.
	//
	// Remarks:
	//    Not all visual objects allow this operation.
	//
	// Parameters:
	//    Box   - Input parameter containing a BOX3D structure
	//
	// Return Value:
	//    S_OK    - Succeeded
	[id(SSCLID_SET_BOUNDINGBOX), helpstring("method SetBoundingBox")]
		HRESULT SetBoundingBox([in] VARIANT Box);

	// Description:
	//    Returns the object's bounding sphere.
	//
	// Remarks:
	//    This function is equivalent to getting the OriginX, OriginY,
	//    OriginZ, and Radius properties.
	//
	// Parameters:
	//    Sphere   - Output parameter to receive a SPHERE3D structure
	//
	// Return Value:
	//    S_OK    - Succeeded
	[id(SSCLID_GET_BOUNDINGSPHERE), helpstring("method GetBoundingSphere")]
		HRESULT GetBoundingSphere([out,retval] VARIANT* Sphere);

	// Description:
	//    Returns the X, Y, and Z axes of the visual object as three
	//    lines
	//
	// Remarks:
	//    This function returns three lines that represent the X, Y, and
	//    Z axes of the object. The scale parameter determines the length
	//    of the lines and is a percentage of the radius of the bounding
	//    sphere.
	//
	// Parameters:
	//    Scale    - Determines length of lines returned, where 1.0 is
	//               the length of the radius of the bounding sphere.
	//    XAxis    - A LINE3D structure containing two points on the
	//               X axis
	//    YAxis    - A LINE3D structure containing two points on the
	//               Y axis
	//    ZAxis    - A LINE3D structure containing two points on the
	//               Z axis
	//
	// Return Value:
	//    S_OK    - Succeeded
	[id(SSCLID_GET_AXES), helpstring("method GetAxes")]
		HRESULT GetAxes([in] VALUE3D Scale,
		                [out] VARIANT* XAxis,
		                [out] VARIANT* YAxis,
		                [out] VARIANT* ZAxis);

	// Description:
	//    Moves the visual object by a specified number of logical units.
	//
	// Remarks:
	//    Updates the transformation matrix with the given translation vector.
	//
	// Parameters:
	//    tx   - X component of the translation vector
	//    ty   - Y component of the translation vector
	//    tz   - Z component of the translation vector
	//
	// Return Value:
	//    S_OK    - Succeeded
	[id(SSCLID_TRANSLATE), helpstring("method Translate")]
		HRESULT Translate([in] VALUE3D tx, [in] VALUE3D ty, [in] VALUE3D tz);

	// Description:
	//    Scales the visual object.
	//
	// Remarks:
	//    Resizes the object by scaling it along on or more axes.
	//
	// Parameters:
	//    sx   - Percentage to scale along X axis (1.0 = no change)
	//    sy   - Percentage to scale along Y axis (1.0 = no change)
	//    sz   - Percentage to scale along Z axis (1.0 = no change)
	//
	// Return Value:
	//    S_OK    - Succeeded
	[id(SSCLID_SCALE), helpstring("method Scale")]
		HRESULT Scale([in] VALUE3D sx, [in] VALUE3D sy, [in] VALUE3D sz);

	// Description:
	//    Rotates the visual object about a given axis.
	//
	// Remarks:
	//    Applies rotation to the transformation matrix.
	//
	// Parameters:
	//    Radians    - Angle of rotation in radians (remember 2*PI radians
	//                 in 360 degrees)
	//    AxisX      - X component of vector about which to rotate the object
	//    AxisY      - Y component of vector about which to rotate the object
	//    AxisZ      - Z component of vector about which to rotate the object
	//
	// Return Value:
	//    S_OK    - Succeeded
	[id(SSCLID_ROTATE), helpstring("method Rotate")]
		HRESULT Rotate([in] VALUE3D Radians,
		               [in] VALUE3D AxisX,
		               [in] VALUE3D AxisY,
		               [in] VALUE3D AxisZ);

	// Description:
	//    Determines if the node intersects the given ray.
	//
	// Remarks:
	//    Tests the bounds of the node to determine if the given ray touches the
	//    node. The Strategy parameter determines how the bounds of the node are
	//    tested.
	//
	// Parameters:
	//    RayOrigin         - POINT3D structure that specifies the ray origin
	//    RayDirection      - VECTOR3D structure that specifies the ray direction
	//    Strategy          - Determines the type of hit test to be performed (used
	//                        to control performance/accuracy tradeoffs)
	//
	// Return Value:
	//    S_OK              - Node intersects the given ray
	//    S_FALSE           - Node does not intersect the given ray
	//    E_POINTER         - Invalid argument passed to the function
	[id(SSCLID_HITTEST_RAY), helpstring("method HitTestRay")]
		HRESULT HitTestRay([in] VARIANT RayOrigin,
		                   [in] VARIANT RayDirection,
		                   [in] enum HitTestStrategy Strategy);

	// Description:
	//    Determines if the node intersects the given sphere.
	//
	// Remarks:
	//    Tests the bounds of the node to determine if the given sphere touches the
	//    node. The Strategy parameter determines how the bounds of the node are
	//    tested.
	//
	// Parameters:
	//    Sphere            - SPHERE3D structure that specifies the sphere to test
	//    Strategy          - Determines the type of hit test to be performed (used
	//                        to control performance/accuracy tradeoffs)
	//
	// Return Value:
	//    S_OK              - Node intersects the given sphere
	//    S_FALSE           - Node does not intersect the given sphere
	//    E_POINTER         - Invalid argument passed to the function
	[id(SSCLID_HITTEST_SPHERE), helpstring("method HitTestSphere")]
		HRESULT HitTestSphere([in] VARIANT Sphere,
		                      [in] enum HitTestStrategy Strategy);

	// Description:
	//    Determines if the node intersects the given box.
	//
	// Remarks:
	//    Tests the bounds of the node to determine if the given box touches the
	//    node. The Strategy parameter determines how the bounds of the node are
	//    tested.
	//
	// Parameters:
	//    Box               - BOX3D structure that specifies the box to test
	//    Strategy          - Determines the type of hit test to be performed (used
	//                        to control performance/accuracy tradeoffs)
	//
	// Return Value:
	//    S_OK              - Node intersects the given box
	//    S_FALSE           - Node does not intersect the given box
	//    E_POINTER         - Invalid argument passed to the function
	[id(SSCLID_HITTEST_BOX), helpstring("method HitTestBox")]
		HRESULT HitTestBox([in] VARIANT Box,
		                   [in] enum HitTestStrategy Strategy);

	// Description:
	//    Determines if the node intersects the given plane.
	//
	// Remarks:
	//    Tests the bounds of the node to determine if the given plane touches the
	//    node. The Strategy parameter determines how the bounds of the node are
	//    tested.
	//
	// Parameters:
	//    Plane             - PLANE3D structure that specifies the plane to test
	//    Strategy          - Determines the type of hit test to be performed (used
	//                        to control performance/accuracy tradeoffs)
	//
	// Return Value:
	//    S_OK              - Node intersects the given plane
	//    S_FALSE           - Node does not intersect the given plane
	//    E_POINTER         - Invalid argument passed to the function
	[id(SSCLID_HITTEST_PLANE), helpstring("method HitTestPlane")]
		HRESULT HitTestPlane([in] VARIANT Plane,
		                     [in] enum HitTestStrategy Strategy);

	// Description:
	//    Recursively hit test the node and its children to determine if their
	//    bounds touch the given ray. All nodes hit by the ray are returned to
	//    the caller in a list.
	//
	// Remarks:
	//    The node is tested first followed by its children. All nodes that are
	//    hit by the ray are appended to the list of nodes passed in.
	//
	// Parameters:
	//    NodeCollection    - Collection in which to add nodes that are hit
	//    RayOrigin         - POINT3D structure that specifies the ray origin
	//    RayDirection      - VECTOR3D structure that specifies the ray direction
	//    Strategy          - Determines the type of hit test to be performed (used
	//                        to control performance/accuracy tradeoffs)
	//
	// Return Value:
	//    S_OK              - The given ray intersects the node or at least one of
	//                        its children
	//    S_FALSE           - The given ray does not intersect the node or any of
	//                        its children
	//    E_POINTER         - Invalid node collection parameter
	[id(SSCLID_GET_CHILDREN_INTERSECTING_RAY), helpstring("method GetChildrenIntersectingRay")]
		HRESULT GetChildrenIntersectingRay([in] INodes* NodeCollection,
		                                   [in] VARIANT RayOrigin,
		                                   [in] VARIANT RayDirection,
		                                   [in] enum HitTestStrategy Strategy);

	// Description:
	//    Recursively hit test the node and its children to determine if their
	//    bounds touch the given sphere. All nodes hit by the sphere are returned to
	//    the caller in a list.
	//
	// Remarks:
	//    The node is tested first followed by its children. All nodes that are
	//    hit by the sphere are appended to the list of nodes passed in.
	//
	// Parameters:
	//    NodeCollection    - Collection in which to add nodes that are hit
	//    Sphere            - SPHERE3D structure that specifies the sphere to test
	//    Strategy          - Determines the type of hit test to be performed (used
	//                        to control performance/accuracy tradeoffs)
	//
	// Return Value:
	//    S_OK              - The given sphere intersects the node or at least one of
	//                        its children
	//    S_FALSE           - The given sphere does not intersect the node or any of
	//                        its children
	//    E_POINTER         - Invalid node collection parameter
	[id(SSCLID_GET_CHILDREN_INTERSECTING_SPHERE), helpstring("method GetChildrenIntersectingSphere")]
		HRESULT GetChildrenIntersectingSphere([in] INodes* NodeCollection,
		                                      [in] VARIANT Sphere,
		                                      [in] enum HitTestStrategy Strategy);

	// Description:
	//    Recursively hit test the node and its children to determine if their
	//    bounds touch the given box. All nodes hit by the box are returned to
	//    the caller in a list.
	//
	// Remarks:
	//    The node is tested first followed by its children. All nodes that are
	//    hit by the box are appended to the list of nodes passed in.
	//
	// Parameters:
	//    NodeCollection    - Collection in which to add nodes that are hit
	//    Box               - BOX3D structure that specifies the box to test
	//    Strategy          - Determines the type of hit test to be performed (used
	//                        to control performance/accuracy tradeoffs)
	//
	// Return Value:
	//    S_OK              - The given box intersects the node or at least one of
	//                        its children
	//    S_FALSE           - The given box does not intersect the node or any of
	//                        its children
	//    E_POINTER         - Invalid node collection parameter
	[id(SSCLID_GET_CHILDREN_INTERSECTING_BOX), helpstring("method GetChildrenIntersectingBox")]
		HRESULT GetChildrenIntersectingBox([in] INodes* NodeCollection,
		                                   [in] VARIANT Box,
		                                   [in] enum HitTestStrategy Strategy);

	// Description:
	//    Recursively hit test the node and its children to determine if their
	//    bounds touch the given plane. All nodes hit by the plane are returned to
	//    the caller in a list.
	//
	// Remarks:
	//    The node is tested first followed by its children. All nodes that are
	//    hit by the plane are appended to the list of nodes passed in.
	//
	// Parameters:
	//    NodeCollection    - Collection in which to add nodes that are hit
	//    Plane             - PLANE3D structure that specifies the plane to test
	//    Strategy          - Determines the type of hit test to be performed (used
	//                        to control performance/accuracy tradeoffs)
	//
	// Return Value:
	//    S_OK              - The given plane intersects the node or at least one of
	//                        its children
	//    S_FALSE           - The given plane does not intersect the node or any of
	//                        its children
	//    E_POINTER         - Invalid node collection parameter
	[id(SSCLID_GET_CHILDREN_INTERSECTING_PLANE), helpstring("method GetChildrenIntersectingPlane")]
		HRESULT GetChildrenIntersectingPlane([in] INodes* NodeCollection,
		                                     [in] VARIANT Plane,
		                                     [in] enum HitTestStrategy Strategy);

	// Description:
	//    Test to see if one or more style flags is set.
	//
	// Remarks:
	//    This function AND's the given mask with the object's style
	//    flags and returns the boolean result.
	//
	// Parameters:
	//    Mask    - Mask indicating the flags to test
	//    Enabled - Boolean result of test. TRUE if all flags in the mask
	//              are set, otherwise FALSE.
	//
	// Return Value:
	//    S_OK      - No errors occurred
	//    E_POINTER - NULL or invalid pointer parameter
	[id(SSCLID_TEST_STYLEFLAGS), helpstring("method TestStyleFlags")]
		HRESULT TestStyleFlags([in] long Mask, [out,retval] VARIANT_BOOL* Enabled);

	// Description:
	//    Set one or more style flags to a given boolean value.
	//
	// Parameters:
	//    Mask    - Indicates the style flags to set
	//    Enabled - Boolean value to set the flags to
	//
	// Return Value:
	//    S_OK      - No errors occurred
	[id(SSCLID_SET_STYLEFLAGS), helpstring("method SetStyleFlags")]
		HRESULT SetStyleFlags([in] long Mask, [in] VARIANT_BOOL Enabled);
};

[
	object,
	uuid(E080DEA5-E832-4a52-911E-51957B7E44B4),
	dual,
	helpstring("IFaceArray Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Encapsulates an array of faces in a mesh. Each entry in a face
//    array is a reference into a mesh.
//
// Remarks:
//    Face arrays are not used for rendering meshes, but are
//    useful for editing and hit testing.
//
// See Also:
//    IMesh
////////////////////////////////////////////////////////////////////////////
interface IFaceArray : IDispatch
{
	// Description:
	//    Return the number of faces in the array.
	[id(SSCLID_GET_FACECOUNT), helpstring("method GetFaceCount")]
		HRESULT GetFaceCount([out,retval] long* NumFaces);

	// Description:
	//    Get the index of the primitive that the given face belongs to.
	[id(SSCLID_GET_FACEPRIMITIVE), helpstring("method GetFacePrimitive")]
		HRESULT GetFacePrimitiveIndex([in] long ArrayIdx,
		                              [out,retval] PrimitiveIndex* PrimIdx);

	// Description:
	//    Get the index of the given face.
	[id(SSCLID_GET_FACEINDEX), helpstring("method GetFaceIndex")]
		HRESULT GetFaceIndex([in] long ArrayIdx,
		                     [out,retval] FaceIndex* FaceIdx);

	// Description:
	//    Add a face to the array.
	[id(SSCLID_ADD_FACE), helpstring("method AddFace")]
		HRESULT AddFace([in] PrimitiveIndex PrimIdx, [in] FaceIndex FaceIdx);

	// Description:
	//    Clear the face array.
	[id(SSCLID_CLEAR), helpstring("method Clear")]
		HRESULT Clear();
};

[
	object,
	uuid(860B48FC-5F9C-4d55-98AD-E574E98074E6),
	dual,
	helpstring("IMesh Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    A mesh is a collection of vertices and rendering primitives that
//    are managed as a single unit. 
//
// Remarks:
//    A mesh contains a vertex buffer that is shared by the primitives
//    in the mesh. The vertices in the primitives are index values into
//    the mesh's vertex buffer. This interface provides methods for
//    managing the vertex buffer and primitives.
//
// See Also:
//    INode
////////////////////////////////////////////////////////////////////////////
interface IMesh : INode
{
	// Description:
	//    Return the number of primitives in the mesh.
	//
	// Parameters:
	//    NumPrimitives  - Output parameter to receive primitive count
	//
	// Return Value:
	//    S_OK      - Successful
	//    E_POINTER - Pointer parameter is NULL or contains invalid address
	[id(SSCLID_GET_PRIMITIVECOUNT), helpstring("method GetPrimitiveCount")]
		HRESULT GetPrimitiveCount([out,retval] PrimitiveCount* NumPrimitives);

	// Description:
	//    Append a primitive to the mesh.
	//
	// Parameters:
	//    pPrimitive - Primitive to append
	//    PrimIdx    - Output parameter to receive index value of new primitive
	//
	// Return Value:
	//    S_OK      - Successful
	//    E_POINTER - Pointer parameter is NULL or contains invalid address
	[id(SSCLID_APPEND_PRIMITIVE), helpstring("method AppendPrimitive")]
		HRESULT AppendPrimitive([in] enum PrimitiveType PrimType,
			                    [out] PrimitiveIndex* PrimIdx);

	// Description:
	//    Index a primitive into the mesh at a given position.
	//
	// Parameters:
	//    pPrimitive - Primitive to insert
	//    PrimIdx    - Index into primitive list indicating position for insert
	//
	// Return Value:
	//    S_OK      - Successful
	//    E_POINTER - Pointer parameter is NULL or contains invalid address
	[id(SSCLID_INSERT_PRIMITIVE), helpstring("method InsertPrimitive")]
		HRESULT InsertPrimitive([in] enum PrimitiveType PrimType,
			                    [in] PrimitiveIndex PrimIdx);

	// Description:
	//    Remove a primitive from the mesh.
	//
	// Parameters:
	//    PrimIdx    - Index into primitive list indicating position for remove
	//
	// Return Value:
	//    S_OK      - Successful
	//    E_POINTER - Pointer parameter is NULL or contains invalid address
	[id(SSCLID_REMOVE_PRIMITIVE), helpstring("method RemovePrimitive")]
		HRESULT RemovePrimitive([in] PrimitiveIndex PrimIdx);

	// Description:
	//    Remove all primitives from the mesh.
	//
	// Return Value:
	//    S_OK      - Successful
	//    E_POINTER - Pointer parameter is NULL or contains invalid address
	[id(SSCLID_REMOVE_ALLPRIMITIVES), helpstring("method RemoveAllPrimitives")]
		HRESULT RemoveAllPrimitives();

	// Description:
	//    Get the number of vertices in an given primitive.
	//
	// Parameters:
	//    PrimIdx     - Index specifying the primitive this function operates on
	//    NumVertices - Output parameter to receive vertex count
	//
	// Return Value:
	//    S_OK         - Successful
	//    E_INVALIDARG - Invalid parameter; PrimIdx out of range
	//    E_POINTER    - Pointer parameter is NULL or contains invalid address
	[id(SSCLID_GET_PRIMITIVE_VERTEXCOUNT), helpstring("method GetPrimitiveVertexCount")]
		HRESULT GetPrimitiveVertexCount([in] PrimitiveIndex PrimIdx,
		                                [out,retval] VertexCount* NumVertices);

	// Description:
	//    Get the handle of a specific vertex in a primitive.
	//
	// Parameters:
	//    PrimIdx     - Index specifying the primitive this function operates on
	//    VertIdx     - Index into the primitive's array of vertices
	//    Vertex      - Output parameter to receive vertex handle
	//
	// Return Value:
	//    S_OK         - Successful
	//    E_INVALIDARG - Invalid parameter; either PrimIdx or VertIdx out of range
	//    E_POINTER    - Pointer parameter is NULL or contains invalid address
	[id(SSCLID_GET_PRIMITIVE_VERTEX), helpstring("method GetPrimitiveVertex")]
		HRESULT GetPrimitiveVertex([in] PrimitiveIndex PrimIdx,
		                           [in] VertexIndex VertIdx,
			                       [out,retval] VertexHandle* Vertex);

	// Description:
	//    Set the handle of a specific vertex in a primitive.
	//
	// Parameters:
	//    PrimIdx     - Index specifying the primitive this function operates on
	//    VertIdx     - Index into the primitive's array of vertices
	//    Vertex      - Vertex handle to assign to primitive
	//
	// Return Value:
	//    S_OK         - Successful
	//    E_INVALIDARG - Invalid parameter; either PrimIdx or VertIdx out of range
	//    E_INVALIDARG - Pointer parameter is NULL or contains invalid address
	[id(SSCLID_SET_PRIMITIVE_VERTEX), helpstring("method SetPrimitiveVertex")]
		HRESULT SetPrimitiveVertex([in] PrimitiveIndex PrimIdx,
		                           [in] VertexIndex VertIdx,
			                       [in] VertexHandle Vertex);

	// Description:
	//    Sequentially initializes a range of vertices in a primitive.
	//
	// Remarks:
	//    Commonly used when loading or creating a mesh. Sequentially
	//    assigns vertex handles to the given range of vertices starting
	//    from a given handle value.
	//
	// Parameters:
	//    PrimIdx      - Index specifying the primitive this function operates on
	//    StartIndex   - Starting offset into the list of vertices
	//    NumVertices  - Number of vertices to set
	//    FirstVert    - Starting vertex handle (incremented by 1 for each vertex)
	//
	// Return Value:
	//    S_OK       - Successful
	[id(SSCLID_SET_PRIMITIVE_VERTEXRANGE), helpstring("method SetPrimitiveVertexRange")]
		HRESULT SetPrimitiveVertexRange([in] PrimitiveIndex PrimIdx,
		                                [in] VertexIndex StartIdx,
		                                [in] VertexCount NumVertices,
		                                [in] VertexHandle FirstVert);

	// Description:
	//    Appends a vertex to the primitive.
	//
	// Parameters:
	//    PrimIdx   - Index specifying the primitive this function operates on
	//    Vertex    - Vertex handle to append
	//
	// Return Value:
	//    S_OK       - Successful
	[id(SSCLID_APPEND_PRIMITIVE_VERTEX), helpstring("method AppendPrimitiveVertex")]
		HRESULT AppendPrimitiveVertex([in] PrimitiveIndex PrimIdx,
		                              [in] VertexHandle Vertex);

	// Description:
	//    Insert a vertex into the primitive at a given position in the vertex list.
	//
	// Parameters:
	//    PrimIdx   - Index specifying the primitive this function operates on
	//    VertIdx   - Position at which to insert the vertex
	//    Vertex    - Vertex handle to insert
	//
	// Return Value:
	//    S_OK       - Successful
	[id(SSCLID_INSERT_PRIMITIVE_VERTEX), helpstring("method InsertPrimitiveVertex")]
		HRESULT InsertPrimitiveVertex([in] PrimitiveIndex PrimIdx,
		                              [in] VertexIndex VertIdx,
		                              [in] VertexHandle Vertex);

	// Description:
	//    Remove a vertex from the primitive.
	//
	// Parameters:
	//    PrimIdx   - Index specifying the primitive this function operates on
	//    VertIdx   - Index of vertex to remove
	//
	// Return Value:
	//    S_OK       - Successful
	[id(SSCLID_REMOVE_PRIMITIVE_VERTEX), helpstring("method RemovePrimitiveVertex")]
		HRESULT RemovePrimitiveVertex([in] PrimitiveIndex PrimIdx,
		                              [in] VertexIndex VertIdx);

	// Description:
	//    Remove all vertices from the primitive.
	//
	// Parameters:
	//    PrimIdx   - Index specifying the primitive this function operates on
	//
	// Return Value:
	//    S_OK       - Successful
	[id(SSCLID_CLEAR_PRIMITIVE), helpstring("method ClearPrimitive")]
		HRESULT ClearPrimitive([in] PrimitiveIndex PrimIdx);

	// Description:
	//    Return the number of faces in the primitive.
	//
	// Remarks:
	//    A face is assumed to be a triangle. The number of faces is a
	//    function of the type of primitive and the number of vertices.
	//
	// Parameters:
	//    PrimIdx    - Index specifying the primitive this function operates on
	//    NumFaces   - Output parameter to receive the face count
	//
	// Return Value:
	//    S_OK       - Successful
	[id(SSCLID_GET_PRIMITIVE_FACECOUNT), helpstring("method GetPrimitiveFaceCount")]
		HRESULT GetPrimitiveFaceCount([in] PrimitiveIndex PrimIdx,
		                              [out,retval] FaceCount* NumFaces);

	// Description:
	//    Return the vertices in a given face.
	//
	// Remarks:
	//    Returns the vertex handles of a given face. This function assumes
	//    that faces are always triangles.
	//
	// Parameters:
	//    PrimIdx    - Index specifying the primitive this function operates on
	//    FaceIdx    - Ordinal value of the face
	//    Vertex1    - Output parameter to receive first vertex handle
	//    Vertex2    - Output parameter to receive second vertex handle
	//    Vertex3    - Output parameter to receive third vertex handle
	//
	// Return Value:
	//    S_OK       - Successful
	[id(SSCLID_GET_PRIMITIVE_FACE), helpstring("method GetPrimitiveFace")]
		HRESULT GetPrimitiveFace([in] PrimitiveIndex PrimIdx,
		                         [in] FaceIndex FaceIdx,
		                         [out] VertexHandle* Vertex1,
		                         [out] VertexHandle* Vertex2,
		                         [out] VertexHandle* Vertex3);

	// Description:
	//    Set the vertices of a given face.
	//
	// Remarks:
	//    Assigns vertex handles to a given triangular face.
	//
	// Parameters:
	//    PrimIdx    - Index specifying the primitive this function operates on
	//    FaceIdx    - Ordinal value of the face
	//    Vertex1    - First vertex handle
	//    Vertex2    - Second vertex handle
	//    Vertex3    - Third vertex handle
	//
	// Return Value:
	//    S_OK       - Successful
	[id(SSCLID_SET_PRIMITIVE_FACE), helpstring("method SetPrimitiveFace")]
		HRESULT SetPrimitiveFace([in] PrimitiveIndex PrimIdx,
		                         [in] FaceIndex FaceIdx,
		                         [in] VertexHandle Vertex1,
		                         [in] VertexHandle Vertex2,
		                         [in] VertexHandle Vertex3);

	// Description:
	//    Add a new face to the primitive.
	//
	// Parameters:
	//    PrimIdx    - Index specifying the primitive this function operates on
	//    Vertex1    - First vertex handle
	//    Vertex2    - Second vertex handle
	//    Vertex3    - Third vertex handle
	//    FaceIdx    - Output parameter to receive index of new face
	//
	// Return Value:
	//    S_OK       - Successful
	[id(SSCLID_ADD_PRIMITIVE_FACE), helpstring("method AddPrimitiveFace")]
		HRESULT AddPrimitiveFace([in] PrimitiveIndex PrimIdx,
		                         [in] VertexHandle Vertex1,
		                         [in] VertexHandle Vertex2,
		                         [in] VertexHandle Vertex3,
		                         [out,retval] FaceIndex* FaceIdx);

	// Description:
	//    Remove a given face from the primitive.
	//
	// Parameters:
	//    PrimIdx    - Index specifying the primitive this function operates on
	//    FaceIdx    - Ordinal value of the face to remove
	//
	// Return Value:
	//    S_OK       - Successful
	[id(SSCLID_REMOVE_PRIMITIVE_FACE), helpstring("method RemovePrimitiveFace")]
		HRESULT RemovePrimitiveFace([in] PrimitiveIndex PrimIdx,
		                            [in] FaceIndex FaceIdx);

	// Description:
	//    Get the value of a vertex field.
	//
	// Parameters:
	//    Vertex     - Handle (index) into vertex buffer
	//    Field      - Indicates which data field to retrieve from the vertex
	//    Val        - Output parameter to receive data field value
	//
	// Return Value:
	//    S_OK      - Successful
	//    E_POINTER - Pointer parameter is NULL or contains invalid address
	[id(SSCLID_GET_VERTEX), helpstring("method GetVertex")]
		HRESULT GetVertex([in] VertexHandle Vertex,
		                  [in] enum VertexField Field,
		                  [out,retval] VARIANT* Val);

	// Description:
	//    Set the value of a vertex field.
	//
	// Parameters:
	//    Vertex     - Handle (index) into vertex buffer
	//    Field      - Indicates which data field to set in the vertex
	//    Val        - Value to assign  to data field
	//
	// Return Value:
	//    S_OK      - Successful
	//    E_POINTER - Pointer parameter is NULL or contains invalid address
	[id(SSCLID_SET_VERTEX), helpstring("method SetVertex")]
		HRESULT SetVertex([in] VertexHandle Vertex,
		                  [in] enum VertexField Field,
		                  [in] VARIANT Val);

	// Description:
	//    Add a new vertex to the mesh.
	//
	// Parameters:
	//    Field      - Indicates which data field to set in the new vertex
	//    Val        - Value to assign to data field
	//    VertexOut  - Output parameter to receive new vertex handle
	//
	// Return Value:
	//    S_OK      - Successful
	//    E_POINTER - Pointer parameter is NULL or contains invalid address
	[id(SSCLID_ADD_VERTEX), helpstring("method AddVertex")]
		HRESULT AddVertex([in] enum VertexField Field,
		                  [in] VARIANT Val,
			              [out,retval] VertexHandle* VertexOut);

	// Description:
	//    Modify the value of a vertex field.
	//
	// Remarks:
	//    If the specified vertex already contains a value (i.e. isn't NULL)
	//    then a new vertex is created. A given entry in the vertex buffer
	//    may be shared by more than one primitive, so this function creates
	//    a new copy of the vertex to avoid side affects.
	//
	// Parameters:
	//    Field      - Indicates which data field to update in the vertex
	//    Val        - Value to assign to data field
	//    VertexIn   - Handle of vertex to modify
	//    VertexOut  - Output parameter to receive new vertex handle
	//
	// Return Value:
	//    S_OK      - Successful
	//    E_POINTER - Pointer parameter is NULL or contains invalid address
	[id(SSCLID_UPDATEVERTEX), helpstring("method UpdateVertex")]
		HRESULT UpdateVertex([in] enum VertexField Field,
		                     [in] VARIANT Val,
			                 [in] VertexHandle VertexIn,
			                 [out] VertexHandle* VertexOut);

	// Description:
	//    Compresses the vertex buffer and removes entries that are not
	//    referenced.
	//
	// Return Value:
	//    S_OK      - Successful
	[id(SSCLID_REMOVE_UNUSEDVERTICES), helpstring("method RemoveUnusedVertices")]
		HRESULT RemoveUnusedVertices();

	// Description:
	//    Calculates normal vectors for every vertex in the mesh.
	//
	// Remarks:
	//    This function may create new entries in the vertex buffer, because
	//    normal vectors are set on a per-vertex basis. Therefore, adjacent
	//    vertices cannot necessarily share the same entry in the vertex
	//    buffer because they belong to different faces and may have
	//    different normal vectors.
	//
	// Parameters:
	//    Algorithm - Indicates how to calculate the vertex normals
	//
	// Return Value:
	//    S_OK      - Successful
	[id(SSCLID_UPDATEVERTEXNORMALS), helpstring("method UpdateVertexNormals")]
		HRESULT UpdateVertexNormals([in] enum VertexNormalAlgorithm Algorithm);

	// Description:
	//    Performs hit testing on individual faces.
	[id(SSCLID_PICK_FACE), helpstring("method PickFace")]
		HRESULT PickFace([in] VARIANT RayOrigin,
		                 [in] VARIANT RayDirection,
		                 [out] PrimitiveIndex* PrimIdx,
		                 [out] FaceIndex* FaceIdx,
		                 [out] VALUE3D* U,
		                 [out] VALUE3D* V,
		                 [out] VALUE3D* Dist);

	// Description:
	//    Device resource ID of the vertex buffer.
	// Remarks:
	//    The device resource ID identifies a resource managed by the device.
	// See Also:
	//    Device
	[propget, id(SSCLID_VERTEXBUFFERID), helpstring("property VertexBufferId")]
		HRESULT VertexBufferId([out, retval] DeviceResourceId *pVal);

	[propput, id(SSCLID_VERTEXBUFFERID), helpstring("property VertexBufferId")]
		HRESULT VertexBufferId([in] DeviceResourceId newVal);

	// Description:
	//    Device resource ID of the index buffer.
	// Remarks:
	//    The device resource ID identifies a resource managed by the device.
	// See Also:
	//    Device
	[propget, id(SSCLID_INDEXBUFFERID), helpstring("property IndexBufferId")]
		HRESULT IndexBufferId([out, retval] DeviceResourceId *pVal);

	[propput, id(SSCLID_INDEXBUFFERID), helpstring("property IndexBufferId")]
		HRESULT IndexBufferId([in] DeviceResourceId newVal);
};

[
	object,
	uuid(32EC03B0-3D3B-4f91-B1E8-74FE23F2577A),
	dual,
	helpstring("IMeshEditor Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Encapsulates a mesh editor object. A mesh editor is an object used
//    to modify meshes.
//
// Remarks:
//    Separating mesh editing into separate objects reduces the
//    complexity of the mesh interface and allows for a variety of
//    specialized editing classes.
//
// See Also:
//    IMesh
////////////////////////////////////////////////////////////////////////////
interface IMeshEditor : IDispatch
{
	// Description:
	//    Assigns a mesh to the editor and starts the editing process
	// Parameters:
	//    Mesh   - Mesh to edit
	[id(SSCLID_BEGINEDIT), helpstring("method BeginEdit")]
		HRESULT BeginEdit([in] IMesh* Mesh);

	// Description:
	//    Selects a primitive for the editor to modify
	// Parameters:
	//    PrimIdx  - Index of primitive to edit (zero based)
	[id(SSCLID_SELECTPRIMITIVE), helpstring("method SelectPrimitive")]
		HRESULT SelectPrimitive([in] PrimitiveIndex PrimIdx);

	// Description:
	//    Appends a vertex to the current primitive
	// Parameters:
	//    Field   - Indicates the type of information passed in the vertex field
	//    Val     - Contains the vertex information in one of the following
	//              structures: POINT3D, VECTOR3D, TEXTURECOORDINATE3D
	// Remarks:
	//    A vertex may contain several different fields such as position, normal
	//    vector, color value, and texture coordinates. The mesh being edited may
	//    support some or all of these fields depending on which Direct3D flexible
	//    vertex format it uses. This function provides the flexibility to pass
	//    different types of vertex information as a VARIANT. The Field parameter
	//    indicates what field(s) are to be accessed in the structure that is
	//    passed.
	// See Also:
	//    SelectPrimitive, POINT3D, VECTOR3D, TEXTURECOORDINATE3D
	[id(SSCLID_APPEND_VERTEX), helpstring("method AppendVertex")]
		HRESULT AppendVertex([in] enum VertexField Field,
		                     [in] VARIANT Val);

	// Description:
	//    Updates a vertex in the current primitive
	// Parameters:
	//    VertIdx - Offset of the vertex in the current primitive to update (zero based)
	//    Field   - Indicates the type of information passed in the vertex field
	//    Val     - Contains the vertex information in one of the following
	//              structures: POINT3D, VECTOR3D, TEXTURECOORDINATE3D
	// Remarks:
	//    A vertex may contain several different fields such as position, normal
	//    vector, color value, and texture coordinates. The mesh being edited may
	//    support some or all of these fields depending on which Direct3D flexible
	//    vertex format it uses. This function provides the flexibility to pass
	//    different types of vertex information as a VARIANT. The Field parameter
	//    indicates what field(s) are to be accessed in the structure that is
	//    passed.
	// See Also:
	//    SelectPrimitive, POINT3D, VECTOR3D, TEXTURECOORDINATE3D
	[id(SSCLID_UPDATEVERTEX), helpstring("method UpdateVertex")]
		HRESULT UpdateVertex([in] VertexIndex VertIdx,
			                 [in] enum VertexField Field,
			                 [in] VARIANT Val);

	// Description:
	//    Removes a vertex in the current primitive
	// Parameters:
	//    VertIdx - Offset of the vertex in the current primitive to update (zero based)
	[id(SSCLID_REMOVE_VERTEX), helpstring("method RemoveVertex")]
		HRESULT RemoveVertex([in] VertexIndex VertIdx);

	// Description:
	//    Updates the position field of a vertex in the current primitive
	// Parameters:
	//    VertIdx - Offset of the vertex in the current primitive to update (zero based)
	//    x       - X component of the position
	//    y       - Y component of the position
	//    z       - Z component of the position
	[id(SSCLID_UPDATEVERTEXPOSITION), helpstring("method UpdateVertexPosition")]
		HRESULT UpdateVertexPosition([in] VertexIndex VertIdx,
		                             [in] VALUE3D x,
		                             [in] VALUE3D y,
		                             [in] VALUE3D z);

	// Description:
	//    Updates the texture coordinate field of a vertex in the current primitive
	// Parameters:
	//    VertIdx - Offset of the vertex in the current primitive to update (zero based)
	//    tu      - Horizontal component of the texture coordinate
	//    tv      - Vertical component of the texture coordinate
	// Remarks:
	//    Texture coordinates determine how textures are mapped onto a mesh. A texture
	//    coordinate has horizontal and vertical components that typically range from
	//    0.0 to 1.0, and are designated U and V respectively. (U,V) = (0.0, 0.0)
	//    indicates the upper left hand corner of the texture and (U,V) = (1.0, 1.0)
	//    indicates the lower right hand corner of the texture. The (U,V) values are
	//    not pixel coordinates but a percentage along the horizontal and vertical
	//    axes of the 2D image.
	[id(SSCLID_UPDATETEXTURECOORDINATE), helpstring("method UpdateTextureCoordinate")]
		HRESULT UpdateTextureCoordinate([in] VertexIndex VertIdx,
		                                [in] VALUE3D tu,
		                                [in] VALUE3D tv);

	// Description:
	//    Appends a triangle to the current primitive.
	// Parameters:
	//    Triangle - TRIANGLE3D structure that contains the three points to add to
	//               the primitive
	// Remarks:
	//    This function appends three new vertices to the current primitive. Only
	//    the location of the vertices is set. Other fields such as normal vector,
	//    color, and texture coordinates must be assigned separately.
	[id(SSCLID_APPEND_FACE), helpstring("method AppendFace")]
		HRESULT AppendFace([in] VARIANT Triangle);

	// Description:
	//    Sets the normal vector for a given face in the current primitive.
	// Parameters:
	//    FaceIdx  - Offset of the face in the current primitive to update (zero based)
	//    NX       - X component of normal vector
	//    NY       - Y component of normal vector
	//    NZ       - Z component of normal vector
	// Remarks:
	//    This function sets the normal vector for all three vertices in a given
	//    face.
	[id(SSCLID_UPDATEFACENORMAL), helpstring("method UpdateFaceNormal")]
		HRESULT UpdateFaceNormal([in] FaceIndex FaceIdx,
							     [in] VALUE3D NX,
							     [in] VALUE3D NY,
							     [in] VALUE3D NZ);

	// Description:
	//    Creates a cube and loads it into the mesh.
	// Parameters:
	//    cx - Width of the cube to create
	//    cy - Height of the cube to create
	//    cz - Depth of the cube to create
	// Remarks:
	//    This function loads the mesh with a triangle list that is organized
	//    into a cube shape
	[id(SSCLID_MAKECUBE), helpstring("method MakeCube")]
		HRESULT MakeCube([in] VALUE3D cx, [in] VALUE3D cy, [in] VALUE3D cz);

	// Description:
	//    Creates a pyramid and loads it into the mesh
	// Parameters:
	//    Base   - Length of the base of the pyramid
	//    Height - Height of the pyramid
	// Remarks:
	//    This function loads the mesh with a triangle list that is organized
	//    into a pyramid shape
	[id(SSCLID_MAKEPYRAMID), helpstring("method MakePyramid")]
		HRESULT MakePyramid([in] VALUE3D Base,
		                    [in] VALUE3D Height);

	// Description:
	//    Creates a sphere and loads it into the mesh
	// Parameters:
	//    Radius         - Radius of the sphere to create
	//    LatitudeCount  - Number of lines of latitude in the sphere
	//    LongitudeCount - Number of lines of longitude in the sphere
	// Remarks:
	//    This function loads the mesh with a triangle list that is organized
	//    into a sphere shape
	[id(SSCLID_MAKESPHERE), helpstring("method MakeSphere")]
		HRESULT MakeSphere([in] VALUE3D Radius,
		                   [in] short LatitudeCount,
		                   [in] short LongitudeCount);

	// Description:
	//    Creates a cylinder and loads it into the mesh
	// Parameters:
	//    Radius    - Radius of the cylinder
	//    Height    - Height of the cylinder
	//    NumSlices - Number of slices through the cylinder
	// Remarks:
	//    This function loads the mesh with a triangle list that is organized
	//    into a cylinder shape
	[id(SSCLID_MAKECYLINDER), helpstring("method MakeCylinder")]
		HRESULT MakeCylinder([in] VALUE3D Radius,
		                     [in] VALUE3D Height,
		                     [in] short NumSlices);

	// Description:
	//    Creates a tube and loads it into the mesh
	// Parameters:
	//    InnerRadius   - Radius to the inner edge of the tube
	//    OuterRadius   - Radius to the outer edge of the tube
	//    Height        - Height of the tube
	//    NumSlices     - Number of slices through the tube
	// Remarks:
	//    A tube is a hollow cylinder. This function loads the mesh with a
	//    triangle list that is organized into a tube shape
	[id(SSCLID_MAKETUBE), helpstring("method MakeTube")]
		HRESULT MakeTube([in] VALUE3D InnerRadius,
		                 [in] VALUE3D OuterRadius,
		                 [in] VALUE3D Height,
		                 [in] short NumSlices);

	// Description:
	//    Creates a cone and loads it into the mesh
	// Parameters:
	//    BaseRadius  - Radius at the base of the cone
	//    Height      - Height of the cone
	//    NumSlices   - Number of slices through the base of the cone
	// Remarks:
	//    This function loads the mesh with a triangle list that is organized
	//    into a cone shape
	[id(SSCLID_MAKECONE), helpstring("method MakeCone")]
		HRESULT MakeCone([in] VALUE3D BaseRadius,
		                 [in] VALUE3D Height,
		                 [in] short NumSlices);

	// Description:
	//    Ends an editing session on a mesh and optimizes the mesh
	// Remarks:
	//    This function releases the mesh held by the mesh editor and removes
	//    unused vertices in the mesh.
	[id(SSCLID_ENDEDIT), helpstring("method EndEdit")]
		HRESULT EndEdit();
};

[
	object,
	uuid(EA741A94-E183-4610-8FC0-0135F99FBC7B),
	dual,
	helpstring("ILight Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Interface to a light. Lights illuminate shapes in the model and
//    determine the color of vertices in the model.
//
// Remarks:
//    There are three types of lights that implement this interface:
//    DirectionalLight, PointLight, and SpotLight. Lights can emit
//    several different types of light: diffuse, specular, and ambient.
//    Diffuse light is light that has direction and reflects off of
//    surfaces. The intensity of diffuse light hitting a vertex depends
//    on the angle at which the light hits the vertex. Specular light
//    causes surfaces with specular material properties to have a shiny
//    appearance. Ambient light has no direction and is everywhere at
//    once. All of these types of lights are specified as RGB values.
//    Note that all lighting calculations performed by the rendering
//    engine are done on a per vertex basis.
//
// See Also:
//    INode, DirectionalLight, PointLight, SpotLight
////////////////////////////////////////////////////////////////////////////
interface ILight : INode
{
	// Description:
	//    Set the color of diffuse light emitted by the light
	// Parameters:
	//    red    - Red component of the diffuse color
	//    green  - Green component of the diffuse color
	//    blue   - Blue component of the diffuse color
	// Remarks:
	//    Diffuse light is the most important component in determining
	//    the color of a vertex. The intensity of diffuse light hitting
	//    a vertex depends on the angle at which the light hits the vertex.
	[id(SSCLID_SET_DIFFUSECOLOR), helpstring("method SetDiffuseColor")]
		HRESULT SetDiffuseColor([in] VALUE3D red,
			                    [in] VALUE3D green,
			                    [in] VALUE3D blue);

	// Description:
	//    Get the color of diffuse light emitted by the light
	// Parameters:
	//    red    - Output parameter to receive red component
	//    green  - Output parameter to receive green component
	//    blue   - Output parameter to receive blue component
	// Remarks:
	//    Diffuse light is the most important component in determining
	//    the color of a vertex. The intensity of diffuse light hitting
	//    a vertex depends on the angle at which the light hits the vertex.
	[id(SSCLID_GET_DIFFUSECOLOR), helpstring("method GetDiffuseColor")]
		HRESULT GetDiffuseColor([out] VALUE3D* red,
			                    [out] VALUE3D* green,
			                    [out] VALUE3D* blue);

	// Description:
	//    Set the color of specular light emitted by the light
	// Parameters:
	//    red    - Red component of the specular color
	//    green  - Green component of the specular color
	//    blue   - Blue component of the specular color
	// Remarks:
	//    Specular color causes surfaces with specular material properties
	//    to have a shiny appearance.
	[id(SSCLID_SET_SPECULARCOLOR), helpstring("method SetSpecularColor")]
		HRESULT SetSpecularColor([in] VALUE3D red,
			                     [in] VALUE3D green,
			                     [in] VALUE3D blue);

	// Description:
	//    Get the color of specular light emitted by the light
	// Parameters:
	//    red    - Output parameter to receive red component
	//    green  - Output parameter to receive green component
	//    blue   - Output parameter to receive blue component
	// Remarks:
	//    Specular color causes surfaces with specular material properties
	//    to have a shiny appearance.
	[id(SSCLID_GET_SPECULARCOLOR), helpstring("method GetSpecularColor")]
		HRESULT GetSpecularColor([out] VALUE3D* red,
			                     [out] VALUE3D* green,
			                     [out] VALUE3D* blue);

	// Description:
	//    Set the color of ambient light emitted by the light
	// Parameters:
	//    red    - Red component of the ambient color
	//    green  - Green component of the ambient color
	//    blue   - Blue component of the ambient color
	// Remarks:
	//    Ambient color has no direction and has the same intensity
	//    everywhere in the scene.
	[id(SSCLID_SET_AMBIENTCOLOR), helpstring("method SetAmbientColor")]
		HRESULT SetAmbientColor([in] VALUE3D red,
			                    [in] VALUE3D green,
			                    [in] VALUE3D blue);

	// Description:
	//    Get the color of ambient light emitted by the light
	// Parameters:
	//    red    - Output parameter to receive red component
	//    green  - Output parameter to receive green component
	//    blue   - Output parameter to receive blue component
	// Remarks:
	//    Ambient color has no direction and has the same intensity
	//    everywhere in the scene.
	[id(SSCLID_GET_AMBIENTCOLOR), helpstring("method GetAmbientColor")]
		HRESULT GetAmbientColor([out] VALUE3D* red,
			                    [out] VALUE3D* green,
			                    [out] VALUE3D* blue);

	// Description:
	//    Set the position of the light in world coordinates
	// Parameters:
	//    x    - X component of the position
	//    y    - Y component of the position
	//    z    - Z component of the position
	// Remarks:
	//    Spot lights and point lights have a position associated with them.
	//    Directional lights do not have a position.
	[id(SSCLID_SET_POSITION), helpstring("method SetPosition")]
		HRESULT SetPosition([in] VALUE3D x, [in] VALUE3D y, [in] VALUE3D z);

	// Description:
	//    Set the direction of the light
	// Parameters:
	//    x    - X component of the direction vector
	//    y    - Y component of the direction vector
	//    z    - Z component of the direction vector
	// Remarks:
	//    Point lights do not support this function since they emit light
	//    in all directions.
	[id(SSCLID_SET_DIRECTION), helpstring("method SetDirection")]
		HRESULT SetDirection([in] VALUE3D x, [in] VALUE3D y, [in] VALUE3D z);

	// Description:
	//    The light index is used by the rendering engine to identify the
	//    light. The model automatically assigns this value when the light
	//    is added to the model.
	[propget, id(SSCLID_LIGHTINDEX), helpstring("property LightIndex")]
		HRESULT LightIndex([out, retval] long *pVal);

	[propput, id(SSCLID_LIGHTINDEX), helpstring("property LightIndex")]
		HRESULT LightIndex([in] long newVal);

	// Description:
	//    This flag enables or disables the light. The light affects the scene
	//    during rendering only if this flag is TRUE.
	[propget, id(SSCLID_ENABLED), helpstring("property Enabled")]
		HRESULT Enabled([out, retval] VARIANT_BOOL *pVal);

	[propput, id(SSCLID_ENABLED), helpstring("property Enabled")]
		HRESULT Enabled([in] VARIANT_BOOL newVal);

	// Description:
	//    X component of the position of the light
	[propget, id(SSCLID_XPOSITION), helpstring("property XPosition")]
		HRESULT XPosition([out, retval] VALUE3D *pVal);

	[propput, id(SSCLID_XPOSITION), helpstring("property XPosition")]
		HRESULT XPosition([in] VALUE3D newVal);

	// Description:
	//    Y component of the position of the light
	[propget, id(SSCLID_YPOSITION), helpstring("property YPosition")]
		HRESULT YPosition([out, retval] VALUE3D *pVal);

	[propput, id(SSCLID_YPOSITION), helpstring("property YPosition")]
		HRESULT YPosition([in] VALUE3D newVal);

	// Description:
	//    Z component of the position of the light
	[propget, id(SSCLID_ZPOSITION), helpstring("property ZPosition")]
		HRESULT ZPosition([out, retval] VALUE3D *pVal);

	[propput, id(SSCLID_ZPOSITION), helpstring("property ZPosition")]
		HRESULT ZPosition([in] VALUE3D newVal);

	// Description:
	//    X component of the direction of the light
	[propget, id(SSCLID_XDIRECTION), helpstring("property XDirection")]
		HRESULT XDirection([out, retval] VALUE3D *pVal);

	[propput, id(SSCLID_XDIRECTION), helpstring("property XDirection")]
		HRESULT XDirection([in] VALUE3D newVal);

	// Description:
	//    Y component of the direction of the light
	[propget, id(SSCLID_YDIRECTION), helpstring("property YDirection")]
		HRESULT YDirection([out, retval] VALUE3D *pVal);

	[propput, id(SSCLID_YDIRECTION), helpstring("property YDirection")]
		HRESULT YDirection([in] VALUE3D newVal);

	// Description:
	//    Z component of the direction of the light
	[propget, id(SSCLID_ZDIRECTION), helpstring("property ZDirection")]
		HRESULT ZDirection([out, retval] VALUE3D *pVal);

	[propput, id(SSCLID_ZDIRECTION), helpstring("property ZDirection")]
		HRESULT ZDirection([in] VALUE3D newVal);

	// Description:
	//    Range of the light. Only affects point lights and spotlights.
	[propget, id(SSCLID_RANGE), helpstring("property Range")]
		HRESULT Range([out, retval] VALUE3D *pVal);

	[propput, id(SSCLID_RANGE), helpstring("property Range")]
		HRESULT Range([in] VALUE3D newVal);

	// Description:
	//    Attenuation determines the intensity of the light over distance. Attenuation
	//    doesn't affect directional lights. Attenuation values typically range between
	//    0.0 and 1.0.
	[propget, id(SSCLID_CONSTANT_ATTENUATION), helpstring("property ConstantAttenuation")]
		HRESULT ConstantAttenuation([out, retval] VALUE3D *pVal);

	[propput, id(SSCLID_CONSTANT_ATTENUATION), helpstring("property ConstantAttenuation")]
		HRESULT ConstantAttenuation([in] VALUE3D newVal);

	// Description:
	//    Attenuation determines the intensity of the light over distance. Attenuation
	//    doesn't affect directional lights. Attenuation values typically range between
	//    0.0 and 1.0.
	[propget, id(SSCLID_LINEAR_ATTENUATION), helpstring("property LinearAttenuation")]
		HRESULT LinearAttenuation([out, retval] VALUE3D *pVal);

	[propput, id(SSCLID_LINEAR_ATTENUATION), helpstring("property LinearAttenuation")]
		HRESULT LinearAttenuation([in] VALUE3D newVal);

	// Description:
	//    Attenuation determines the intensity of the light over distance. Attenuation
	//    doesn't affect directional lights. Attenuation values typically range between
	//    0.0 and 1.0.
	[propget, id(SSCLID_QUADRATIC_ATTENUATION), helpstring("property QuadraticAttenuation")]
		HRESULT QuadraticAttenuation([out, retval] VALUE3D *pVal);

	[propput, id(SSCLID_QUADRATIC_ATTENUATION), helpstring("property QuadraticAttenuation")]
		HRESULT QuadraticAttenuation([in] VALUE3D newVal);
};

[
	object,
	uuid(2AC03EF4-EC26-4a9b-A31D-85B055D19175),
	dual,
	helpstring("ISpotLight Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Interface to a spotlight. A spotlight is a cone of light that is
//    emitted from a given point in a given direction.
//
// Remarks:
//    Spotlights have an inner cone and outer cone defined. The intensity
//    of the light in the inner cone is different than the intensity in the
//    outer cone and is regulated by the FallOff property.
//
// See Also:
//    ILight, SpotLight
////////////////////////////////////////////////////////////////////////////
interface ISpotLight : ILight
{
	// Description:
	//    Determines the decrease in illumination between the spotlight's
	//    inner cone and the outer edge of the outer cone. A value of 1.0
	//    indicates no decrease.
	[propget, id(SSCLID_FALLOFF), helpstring("property FallOff")]
		HRESULT FallOff([out, retval] VALUE3D *pVal);

	[propput, id(SSCLID_FALLOFF), helpstring("property FallOff")]
		HRESULT FallOff([in] VALUE3D newVal);

	// Description:
	//    Angle of the spotlight's inner cone in radians.
	[propget, id(SSCLID_INNER_SPOTLIGHT_CONE_ANGLE), helpstring("property InnerSpotlightConeAngle")]
		HRESULT InnerSpotlightConeAngle([out, retval] VALUE3D *pVal);

	[propput, id(SSCLID_INNER_SPOTLIGHT_CONE_ANGLE), helpstring("property InnerSpotlightConeAngle")]
		HRESULT InnerSpotlightConeAngle([in] VALUE3D newVal);

	// Description:
	//    Angle of the spotlight's outer cone in radians.
	[propget, id(SSCLID_OUTER_SPOTLIGHT_CONE_ANGLE), helpstring("property OuterSpotlightConeAngle")]
		HRESULT OuterSpotlightConeAngle([out, retval] VALUE3D *pVal);

	[propput, id(SSCLID_OUTER_SPOTLIGHT_CONE_ANGLE), helpstring("property OuterSpotlightConeAngle")]
		HRESULT OuterSpotlightConeAngle([in] VALUE3D newVal);
};

[
	object,
	uuid(F6D7AD9D-9CDE-4b86-9DE0-316EB65455A5),
	dual,
	helpstring("IMaterial Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Interface to a material. Materials determine how lighting calculations
//    affect the vertices that make up shapes in the scene. The material
//    determines how much diffuse, specular, and ambient light is reflected
//    off of the vertices in the shape. A material can also specify emissive
//    color, which indicates that the surfaces emit light.
//
// Remarks:
//    Materials are context objects that are applied to shapes and
//    associated with one or more primitives that comprise the shape's mesh.
//
// See Also:
//    INode
////////////////////////////////////////////////////////////////////////////
interface IMaterial : INode
{
	// Description:
	//    Set the diffuse color of the material
	// Parameters:
	//    red    - Red component of the diffuse color
	//    green  - Green component of the diffuse color
	//    blue   - Blue component of the diffuse color
	//    alpha  - Alpha transparency value
	// Remarks:
	//    The diffuse color setting in a material determines how much
	//    diffuse light the material reflects.
	[id(SSCLID_SET_DIFFUSECOLOR), helpstring("method SetDiffuseColor")]
		HRESULT SetDiffuseColor([in] VALUE3D red,
			                    [in] VALUE3D green,
			                    [in] VALUE3D blue,
			                    [in] VALUE3D alpha);

	// Description:
	//    Get the diffuse color of the material
	// Parameters:
	//    red     - Output parameter to receive red component of diffuse color
	//    green   - Output parameter to receive green component of diffuse color
	//    blue    - Output parameter to receive blue component of diffuse color
	//    alpha   - Output parameter to receive alpha transparency value
	// Remarks:
	//    The diffuse color setting in a material determines how much
	//    diffuse light the material reflects.
	[id(SSCLID_GET_DIFFUSECOLOR), helpstring("method GetDiffuseColor")]
		HRESULT GetDiffuseColor([out] VALUE3D* red,
			                    [out] VALUE3D* green,
			                    [out] VALUE3D* blue,
			                    [out] VALUE3D* alpha);

	// Description:
	//    Set the specular color of the material
	// Parameters:
	//    red    - Red component of the specular color
	//    green  - Green component of the specular color
	//    blue   - Blue component of the specular color
	//    alpha  - Alpha transparency value
	// Remarks:
	//    The specular color setting in a material determines the shininess
	//    of the material
	[id(SSCLID_SET_SPECULARCOLOR), helpstring("method SetSpecularColor")]
		HRESULT SetSpecularColor([in] VALUE3D red,
			                     [in] VALUE3D green,
			                     [in] VALUE3D blue, 
			                     [in] VALUE3D alpha);

	// Description:
	//    Set the specular color of the material
	// Parameters:
	//    red     - Output parameter to receive red component of specular color
	//    green   - Output parameter to receive green component of specular color
	//    blue    - Output parameter to receive blue component of specular color
	//    alpha   - Output parameter to receive alpha transparency value
	// Remarks:
	//    The specular color setting in a material determines the shininess
	//    of the material
	[id(SSCLID_GET_SPECULARCOLOR), helpstring("method GetSpecularColor")]
		HRESULT GetSpecularColor([out] VALUE3D* red,
			                     [out] VALUE3D* green,
			                     [out] VALUE3D* blue,
			                     [out] VALUE3D* alpha);

	// Description:
	//    Set the ambient color of the material
	// Parameters:
	//    red    - Red component of the ambient color
	//    green  - Green component of the ambient color
	//    blue   - Blue component of the ambient color
	//    alpha  - Alpha transparency value
	// Remarks:
	//    The ambient color setting in a material determines how much
	//    ambient light the material reflects
	[id(SSCLID_SET_AMBIENTCOLOR), helpstring("method SetAmbientColor")]
		HRESULT SetAmbientColor([in] VALUE3D red,
			                    [in] VALUE3D green,
			                    [in] VALUE3D blue,
			                    [in] VALUE3D alpha);

	// Description:
	//    Get the ambient color of the material
	// Parameters:
	//    red     - Output parameter to receive red component of ambient color
	//    green   - Output parameter to receive green component of ambient color
	//    blue    - Output parameter to receive blue component of ambient color
	//    alpha   - Output parameter to receive alpha transparency value
	// Remarks:
	//    The ambient color setting in a material determines how much
	//    ambient light the material reflects
	[id(SSCLID_GET_AMBIENTCOLOR), helpstring("method GetAmbientColor")]
		HRESULT GetAmbientColor([out] VALUE3D* red,
			                    [out] VALUE3D* green,
			                    [out] VALUE3D* blue,
			                    [out] VALUE3D* alpha);

	// Description:
	//    Set the emissive color of the material
	// Parameters:
	//    red    - Red component of the emissive color
	//    green  - Green component of the emissive color
	//    blue   - Blue component of the emissive color
	//    alpha  - Alpha transparency value
	// Remarks:
	//    The emissive color setting in a material determines how much
	//    light the material emits
	[id(SSCLID_SET_EMISSIVECOLOR), helpstring("method SetEmissiveColor")]
		HRESULT SetEmissiveColor([in] VALUE3D red,
			                     [in] VALUE3D green,
			                     [in] VALUE3D blue,
			                     [in] VALUE3D alpha);

	// Description:
	//    Get the emissive color of the material
	// Parameters:
	//    red     - Output parameter to receive red component of emissive color
	//    green   - Output parameter to receive green component of emissive color
	//    blue    - Output parameter to receive blue component of emissive color
	//    alpha   - Output parameter to receive alpha transparency value
	// Remarks:
	//    The emissive color setting in a material determines how much
	//    light the material emits
	[id(SSCLID_GET_EMISSIVECOLOR), helpstring("method GetEmissiveColor")]
		HRESULT GetEmissiveColor([out] VALUE3D* red,
			                     [out] VALUE3D* green,
			                     [out] VALUE3D* blue,
			                     [out] VALUE3D* alpha);
};

[
	object,
	uuid(0D945B78-C4CD-44f6-B239-55DCE81C0242),
	dual,
	helpstring("ITexture Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Interface to a texture. A texture is a bitmap image that is mapped
//    onto a primitive during rendering to provide a more realistic
//    appearance.
//
// Remarks:
//    A texture is a 2D bitmap image that is typically loaded from a
//    file into video memory. Textures are loaded into a Device object
//    and assigned a handle (TextureId) that can be used to access the
//    texture on the device.
//
// See Also:
//    INode, Texture
////////////////////////////////////////////////////////////////////////////
interface ITexture : INode
{
	// Description:
	//    This property contains a handle that identifies the texture on
	//    a given device. It is typically assigned automatically when the
	//    texture is loaded onto the device when IDeviceResource::LoadDevice
	//    is called.
	[propget, id(SSCLID_TEXTUREID), helpstring("property TextureId")]
		HRESULT TextureId([out, retval] DeviceResourceId *pVal);

	[propput, id(SSCLID_TEXTUREID), helpstring("property TextureId")]
		HRESULT TextureId([in] DeviceResourceId newVal);

	// Description:
	//    The width of the texture in pixels
	[propget, id(SSCLID_WIDTH), helpstring("property Width")]
		HRESULT Width([out, retval] long *pVal);

	[propput, id(SSCLID_WIDTH), helpstring("property Width")]
		HRESULT Width([in] long newVal);

	// Description:
	//    The height of the texture in pixels
	[propget, id(SSCLID_HEIGHT), helpstring("property Height")]
		HRESULT Height([out, retval] long *pVal);

	[propput, id(SSCLID_HEIGHT), helpstring("property Height")]
		HRESULT Height([in] long newVal);

	// Description:
	//    Name of file to load bitmap image from.
	[propget, id(SSCLID_FILENAME), helpstring("property FileName")]
		HRESULT FileName([out, retval] BSTR *pVal);

	[propput, id(SSCLID_FILENAME), helpstring("property FileName")]
		HRESULT FileName([in] BSTR newVal);
};

[
	object,
	uuid(AA24D0A1-EAFA-4458-B35B-64611778EFA4),
	dual,
	helpstring("ITextureStage Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Interface to a texture stage. A texture stage is used for advanced
//    texture blending. It allows multiple textures to be combined using
//    various operations at each stage. It can also be used to associate
//    texture state settings with a single stage texture.
//
// Remarks:
//    Each texture stage is assigned an ordinal value that indicates its
//    ordering during rendering. A single texture is associated with each
//    texture stage. Texture stage states can also be assigned to the
//    texture stage. Texture stage states control various texture mapping
//    options such as texture addressing mode, alpha blending, mipmap
//    filtering, and bump mapping. Texture stage states are defined by
//    the TextureStageStateType enumeration.
//
// See Also:
//    ICompositeNode, TextureStageStateType
////////////////////////////////////////////////////////////////////////////
interface ITextureStage : ICompositeNode
{
	// Description:
	//    Identifier used by the rendering engine to determine the ordering
	//    of texture stages.
	[propget, id(SSCLID_TEXTURE_STAGENUM), helpstring("property StageNum")]
		HRESULT StageNum([out, retval] long *pVal);

	[propput, id(SSCLID_TEXTURE_STAGENUM), helpstring("property StageNum")]
		HRESULT StageNum([in] long newVal);

	// Description:
	//    Texture associated with the texture stage.
	[propget, id(SSCLID_TEXTURE), helpstring("property Texture")]
		HRESULT Texture([out, retval] ITexture** Texture);

	[propputref, id(SSCLID_TEXTURE), helpstring("property Texture")]
		HRESULT Texture([in] ITexture* Texture);

	// Description:
	//    Sets the value of a texture state that provides instructions to
	//    the rendering engine about how to process the texture
	// Parameters:
	//    StateType    - Identifies which processing instruction to set
	//    StateValue   - Value to assign to the state
	// Remarks:
	//    Texture states are ID/value pairs that provide instructions to
	//    the rendering engine about how to process a texture.
	// See Also:
	//    TextureStageStateType
	[id(SSCLID_SET_TEXTURESTATE), helpstring("method SetTextureState")]
		HRESULT SetTextureState([in] short StateType,
		                        [in] long StateValue);

	// Description:
	//    Sets the value of a texture state that provides instructions to
	//    the rendering engine about how to process the texture
	// Parameters:
	//    StateType    - Identifies which processing instruction to set
	//    StateValue   - Value to assign to the state
	// Remarks:
	//    Texture states are ID/value pairs that provide instructions to
	//    the rendering engine about how to process a texture.
	// See Also:
	//    TextureStageStateType
	[id(SSCLID_SET_TEXTURESTATEFLOAT), helpstring("method SetTextureStateFloat")]
		HRESULT SetTextureStateFloat([in] short StateType,
		                             [in] float StateValue);

	// Description:
	//    Sets the value of a texture state that provides instructions to
	//    the rendering engine about how to process the texture
	// Parameters:
	//    StateType    - Identifies which processing instruction to set
	//    StateValue   - Value to assign to the state
	// Remarks:
	//    Texture states are ID/value pairs that provide instructions to
	//    the rendering engine about how to process a texture.
	// See Also:
	//    TextureStageStateType
	[id(SSCLID_SET_TEXTURESTATERGBA), helpstring("method SetTextureStateRGBA")]
		HRESULT SetTextureStateRGBA([in] short StateType,
		                            [in] VALUE3D Red,
		                            [in] VALUE3D Green,
		                            [in] VALUE3D Blue,
		                            [in] VALUE3D Alpha);

	// Description:
	//    Remove a texture state value and revert to using the default
	//    provided by the rendering engine
	// Parameters:
	//    StateType    - Identifies which processing instruction to remove
	// Remarks:
	//    Texture states are ID/value pairs that provide instructions to
	//    the rendering engine about how to process a texture.
	// See Also:
	//    TextureStageStateType
	[id(SSCLID_CLEAR_TEXTURESTATE), helpstring("method ClearTextureState")]
		HRESULT ClearTextureState([in] short StateType);

	// Description:
	//    Remove all texture state values and revert to using the defaults
	//    provided by the rendering engine
	// Remarks:
	//    Texture states are ID/value pairs that provide instructions to
	//    the rendering engine about how to process a texture.
	// See Also:
	//    TextureStageStateType
	[id(SSCLID_CLEAR_ALLTEXTURESTATES), helpstring("method ClearAllTextureStates")]
		HRESULT ClearAllTextureStates();
};

[
	object,
	uuid(B03C65A1-DA4A-468a-9005-7E19A1574E1D),
	dual,
	helpstring("IRenderingContext Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Interface to rendering contexts. A rendering context is a node that
//    contains other context objects such as textures, materials, and
//    texture stages. Rendering context objects also contain rendering
//    states which are ID/value pairs that provide instructions to the
//    rendering engine.
//
// Remarks:
//    Context objects such as textures, materials, and texture stages can
//    be added to a rendering context through the ICompositeNode interface.
//
// See Also:
//    ICompositeNode, RenderStateType
////////////////////////////////////////////////////////////////////////////
interface IRenderingContext : ICompositeNode
{
	// Description:
	//    Get the value of a given rendering state
	// Parameters:
	//    StateId   - Identifies which state value will be retrieved
	//    StateVal  - Receives the value assigned to the rendering state
	// Remarks:
	//    Rendering states are ID/value pairs that provide instructions to
	//    the rendering engine.
	// See Also:
	//    RenderStateType
	[id(SSCLID_GET_RENDERSTATE), helpstring("method GetRenderState")]
		HRESULT GetRenderState([in] short StateId, [out,retval] long* StateVal);

	// Description:
	//    Set the value of a given rendering state
	// Parameters:
	//    StateId   - Identifies which state value will be assigned a new value
	//    StateVal  - Value to be assigned to the rendering state
	// Remarks:
	//    Rendering states are ID/value pairs that provide instructions to
	//    the rendering engine.
	// See Also:
	//    RenderStateType
	[id(SSCLID_SET_RENDERSTATE), helpstring("method SetRenderState")]
		HRESULT SetRenderState([in] short StateId, [in] long StateVal);

	// Description:
	//    Removes a rendering state from the rendering context
	// Parameters:
	//    StateId   - Identifies which state value to remove
	// Remarks:
	//    Rendering states are ID/value pairs that provide instructions to
	//    the rendering engine.
	// See Also:
	//    RenderStateType
	[id(SSCLID_REMOVE_RENDERSTATE), helpstring("method RemoveRenderState")]
		HRESULT RemoveRenderState([in] short StateId);
};

[
	object,
	uuid(746B466B-EB54-4fba-B83A-A5F5D0C8CB7B),
	dual,
	helpstring("IShape Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    A shape is a visual object that contains a mesh and context
//    information for rendering the mesh. Context information consists
//    of materials, textures, texture stages, and rendering context blocks
//    that define the rendering for each primitive in the mesh.
//
// Remarks:
//    Each primitive in the associated mesh can have a context object
//    associated with it.
//
// See Also:
//    IVisual, IMesh
////////////////////////////////////////////////////////////////////////////
interface IShape : IVisual
{
	// Description:
	//    Mesh associated with the shape. Each shape can be associated
	//    with a single mesh. A single mesh may be associated with many
	//    shapes.
	[propget, id(SSCLID_MESH), helpstring("property Mesh")]
		HRESULT Mesh([out, retval] IMesh** ppVal);

	[propputref, id(SSCLID_MESH), helpstring("property Mesh")]
		HRESULT Mesh([in] IMesh* Mesh);

	// Description:
	//    Assigns a context object to a given primitive in the shape's
	//    mesh.
	// Parameters:
	//    PrimIdx     - Index of a primitive in the mesh associated with
	//                  the shape
	//    ContextNode - Any context object such as a RenderingContext,
	//                  Material, Texture, or TextureStage
	// Remarks:
	//    Only one context object can be associated with each primitive.
	//    RenderingContext objects are frequently used because they are
	//    composite objects that may contain any number of context
	//    objects as children. The can also be assigned rendering states
	//    which are instructions to the rendering engine.
	[id(SSCLID_SET_CONTEXT), helpstring("method SetContext")]
		HRESULT SetContext([in] PrimitiveIndex PrimIdx,
		                   [in] INode* ContextNode);

	// Description:
	//    Gets the context object associated with a given primitive in
	//    the shape's mesh.
	// Parameters:
	//    PrimIdx     - Index of the primitive in the mesh (zero based)
	//    ContextNode - Receives the context object
	[id(SSCLID_GET_CONTEXT), helpstring("method GetContext")]
		HRESULT GetContext([in] PrimitiveIndex PrimIdx,
		                   [out,retval] INode** ContextNode);

	// Description:
	//    Removes the context object associated with a given primitive.
	// Parameters:
	//    PrimIdx   - Index of the primitive whose context is to be
	//                cleared (zero based)
	[id(SSCLID_CLEAR_CONTEXT), helpstring("method ClearContext")]
		HRESULT ClearContext([in] PrimitiveIndex PrimIdx);
};

[
	object,
	uuid(C2F97591-B14D-405e-99EF-D747E5A8B1F6),
	dual,
	helpstring("IBSPTree Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Interface to a binary space partitioning tree.
//
// Remarks:
//    BSP trees are used to speed up hit testing and collision
//    detection. A BSP tree is a binary tree that provides a spatial index
//    of nodes in a model. It is used to quickly find nodes in a given region
//    of space. It speeds up hit testing and collision detection by reducing
//    the number of nodes that must be tested. The area to be indexed is
//    specified by the IBSPTree::SetVolume function and the number of
//    partitions defines how volume is divided up. The number of partitions
//    specified determines the number of leaf nodes in the binary tree.
//
// See Also:
//    BSPTree
////////////////////////////////////////////////////////////////////////////
interface IBSPTree: IDispatch
{
	// Description:
	//    Creates the nodes in the BSP tree based on the volume and number
	//    of partitions.
	// Remarks:
	//    This function destroys the contents of the BSP tree (if any) and
	//    rebuilds the tree based on the volume and number of partitions.
	//    The volume is divided up into the number of partitions specified.
	//    The number of leaf nodes in the tree is equal to
	//    (NumXPartitions+1) * (NumYPartitions+1) * (NumZPartitions+1)
	[id(SSCLID_INITIALIZE), helpstring("method Initialize")]
		HRESULT Initialize();

	// Description:
	//    Sets the volume of the root node.
	// Parameters:
	//    Left     - Left edge of the bounding box
	//    Right    - Right edge of the bounding box
	//    Top      - Top edge of the bounding box
	//    Bottom   - Bottom edge of the bounding box
	//    Front    - Front edge of the bounding box
	//    Back     - Back edge of the bounding box
	// Remarks:
	//    The volume defines the total area of space indexed by the
	//    BSP tree. The volume is partitioned along the X, Y, and Z axes
	//    according to the values set by IBSPTree::SetPartitions.
	[id(SSCLID_SET_VOLUME), helpstring("method SetVolume")]
		HRESULT SetVolume([in] VALUE3D Left,
		                  [in] VALUE3D Right,
		                  [in] VALUE3D Top,
		                  [in] VALUE3D Bottom,
		                  [in] VALUE3D Front,
		                  [in] VALUE3D Back);

	// Description:
	//    Sets the number of partitions along each axis.
	// Parameters:
	//    NumXPartitions   - Number of partitions to create along the X axis
	//    NumYPartitions   - Number of partitions to create along the Y axis
	//    NumZPartitions   - Number of partitions to create along the Z axis
	// Remarks:
	//    The number of leaf nodes in the BSP tree is equal to
	//    (NumXPartitions+1) * (NumYPartitions+1) * (NumZPartitions+1)
	[id(SSCLID_SET_PARTITIONS), helpstring("method SetPartitions")]
		HRESULT SetPartitions([in] long NumXPartitions, 
		                      [in] long NumYPartitions, 
		                      [in] long NumZPartitions);

	// Description:
	//    Adds a visual object to the BSP tree
	// Parameters:
	//    Object    - Object to add to the BSP tree
	//    Recursive - Flag indicating if children of the given object should
	//                also be added
	// Remarks:
	//    The object must support the IVisual interface in order to be added
	//    to the BSP tree.
	[id(SSCLID_ADD_OBJECT), helpstring("method AddObject")]
		HRESULT AddObject([in] INode* Object, [in] VARIANT_BOOL Recursive);

	// Description:
	//    Updates a visual object in the BSP tree
	// Parameters:
	//    Object    - Object to update in the BSP tree
	//    Recursive - Flag indicating if children of the given object should
	//                also be updated
	// Remarks:
	//    The object must support the IVisual interface in order to be updated
	//    in the BSP tree. This function simply removes the object and re-adds
	//    it.
	[id(SSCLID_UPDATE_OBJECT), helpstring("method UpdateObject")]
		HRESULT UpdateObject([in] INode* Object, [in] VARIANT_BOOL Recursive);

	// Description:
	//    Removes an object from the BSP tree.
	// Parameters:
	//    Object    - Object to remove from the BSP tree
	//    Recursive - Flag indicating if children of the given object should
	//                also be removed
	[id(SSCLID_REMOVE_OBJECT), helpstring("method RemoveObject")]
		HRESULT RemoveObject([in] INode* Object, [in] VARIANT_BOOL Recursive);

	// Description:
	//    Removes all objects from the BSP tree.
	// Remarks:
	//    This function loops through each leaf node in the tree and removes
	//    all entries from each leaf node.
	[id(SSCLID_REMOVE_ALL_OBJECTS), helpstring("method RemoveAllObjects")]
		HRESULT RemoveAllObjects();

	// Description:
	//    Return all visual objects that touch the given ray.
	//
	// Parameters:
	//    NodeCollection    - Collection in which to add nodes that are hit
	//    RayOrigin         - POINT3D structure that specifies the ray origin
	//    RayDirection      - VECTOR3D structure that specifies the ray direction
	//    Strategy          - Determines the type of hit test to be performed (used
	//                        to control performance/accuracy tradeoffs)
	//
	// Return Value:
	//    S_OK              - The given ray intersects the node or at least one of
	//                        its children
	//    S_FALSE           - The given ray does not intersect the node or any of
	//                        its children
	//    E_POINTER         - Invalid node collection parameter
	[id(SSCLID_GET_CHILDREN_INTERSECTING_RAY), helpstring("method GetChildrenIntersectingRay")]
		HRESULT GetChildrenIntersectingRay([in] INodes* NodeCollection,
		                                   [in] VARIANT RayOrigin,
		                                   [in] VARIANT RayDirection,
		                                   [in] enum HitTestStrategy Strategy);

	// Description:
	//    Return all visual objects that touch the given sphere.
	//
	// Parameters:
	//    NodeCollection    - Collection in which to add nodes that are hit
	//    Sphere            - SPHERE3D structure that specifies the sphere to test
	//    Strategy          - Determines the type of hit test to be performed (used
	//                        to control performance/accuracy tradeoffs)
	//
	// Return Value:
	//    S_OK              - The given sphere intersects the node or at least one of
	//                        its children
	//    S_FALSE           - The given sphere does not intersect the node or any of
	//                        its children
	//    E_POINTER         - Invalid node collection parameter
	[id(SSCLID_GET_CHILDREN_INTERSECTING_SPHERE), helpstring("method GetChildrenIntersectingSphere")]
		HRESULT GetChildrenIntersectingSphere([in] INodes* NodeCollection,
		                                      [in] VARIANT Sphere,
		                                      [in] enum HitTestStrategy Strategy);

	// Description:
	//    Return all visual objects that touch the given box.
	//
	// Parameters:
	//    NodeCollection    - Collection in which to add nodes that are hit
	//    Box               - BOX3D structure that specifies the box to test
	//    Strategy          - Determines the type of hit test to be performed (used
	//                        to control performance/accuracy tradeoffs)
	//
	// Return Value:
	//    S_OK              - The given box intersects the node or at least one of
	//                        its children
	//    S_FALSE           - The given box does not intersect the node or any of
	//                        its children
	//    E_POINTER         - Invalid node collection parameter
	[id(SSCLID_GET_CHILDREN_INTERSECTING_BOX), helpstring("method GetChildrenIntersectingBox")]
		HRESULT GetChildrenIntersectingBox([in] INodes* NodeCollection,
		                                   [in] VARIANT Box,
		                                   [in] enum HitTestStrategy Strategy);

	// Description:
	//    Return all visual objects that touch the given plane.
	//
	// Parameters:
	//    NodeCollection    - Collection in which to add nodes that are hit
	//    Plane             - PLANE3D structure that specifies the plane to test
	//    Strategy          - Determines the type of hit test to be performed (used
	//                        to control performance/accuracy tradeoffs)
	//
	// Return Value:
	//    S_OK              - The given plane intersects the node or at least one of
	//                        its children
	//    S_FALSE           - The given plane does not intersect the node or any of
	//                        its children
	//    E_POINTER         - Invalid node collection parameter
	[id(SSCLID_GET_CHILDREN_INTERSECTING_PLANE), helpstring("method GetChildrenIntersectingPlane")]
		HRESULT GetChildrenIntersectingPlane([in] INodes* NodeCollection,
		                                     [in] VARIANT Plane,
		                                     [in] enum HitTestStrategy Strategy);
};

[
	object,
	uuid(82A5F7BB-480F-484e-9B2E-0D8D5A9F2B83),
	dual,
	helpstring("IModel Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    A model is a visual object that contains other types of nodes such
//    as shapes, textures, materials, namespaces, and lights. A model can
//    be attached to one or more viewports and is rendered by the
//    viewports that observe it.
//
// Remarks:
//    A model is a collection of objects that are rendered as a single
//    unit. Models can be nested.
//
// See Also:
//    IVisual, INode
////////////////////////////////////////////////////////////////////////////
interface IModel : IVisual
{
	// Description:
	//    The measurement scale is used to convert between logical units and
	//    real world units.
	[propget, id(SSCLID_MEASUREMENT_SCALE), helpstring("property MeasurementScale")]
		HRESULT MeasurementScale([out, retval] IMeasurementScale** ppVal);

	[propputref, id(SSCLID_MEASUREMENT_SCALE), helpstring("property MeasurementScale")]
		HRESULT MeasurementScale([in] IMeasurementScale* pNewVal);

	// Description:
	//    Removes all nodes from the model.
	[id(SSCLID_CLEAR), helpstring("method Clear")]
		HRESULT Clear();

	// Description:
	//    Sets the amount of ambient light in the model.
	// Parameters:
	//    red    - Red component of the ambient color
	//    green  - Green component of the ambient color
	//    blue   - Blue component of the ambient color
	// Remarks:
	//    Ambient light has the same intensity throughout the scene. It does
	//    not have position or direction. Only surfaces with ambient light
	//    material settings will reflect ambient light.
	[id(SSCLID_SET_AMBIENTLIGHT), helpstring("method SetAmbientLight")]
		HRESULT SetAmbientLight([in] VALUE3D red,
			                    [in] VALUE3D green,
			                    [in] VALUE3D blue,
			                    [in] VALUE3D alpha);

	// Description:
	//    Get the ambient light settings for the model.
	// Parameters:
	//    red    - Output parameter to receive red component
	//    green  - Output parameter to receive green component
	//    blue   - Output parameter to receive blue component
	// Remarks:
	//    Ambient light has the same intensity throughout the scene. It does
	//    not have position or direction. Only surfaces with ambient light
	//    material settings will reflect ambient light.
	[id(SSCLID_GET_AMBIENTLIGHT), helpstring("method GetAmbientLight")]
		HRESULT GetAmbientLight([in] VALUE3D* red,
			                    [in] VALUE3D* green,
			                    [in] VALUE3D* blue,
			                    [in] VALUE3D* alpha);

	// Description:
	//    Create a node in the model
	// Parameters:
	//    Name     - Name to assign to the new node
	//    ProgID   - Type of node to create
	//    Parent   - Fully qualified name of a node that will be the
	//               parent of the new node. If NULL or empty string, then
	//               the model will be the parent.
	//    Obj      - Receives the newly created node
	// Remarks:
	//    This function can be used to create any type of node in the model.
	[id(SSCLID_CREATE_NODE), helpstring("method CreateNode")]
		HRESULT CreateNode([in] BSTR Name,
			               [in] BSTR ProgID,
			               [in] BSTR Parent,
			               [out,retval] INode** Obj);

	// Description:
	//    Insert one node into a node the model.
	// Parameters:
	//    Node       - Node to add
	//    Parent     - Fully qualified name of a node that will be the
	//                 parent of the node inserted
	//    ChildIndex - Position in which to insert child into parent. A
	//                 value of -1 appends the child to the end of the list.
	[id(SSCLID_INSERT_NODE), helpstring("method InsertNodes")]
		HRESULT InsertNode([in] INode* Node, [in] BSTR Parent, [in] long ChildIndex);

	// Description:
	//    Append one or more nodes to a node in the model.
	// Parameters:
	//    NodeCollection   - List of nodes to add
	//    Parent           - Fully qualified name of the parent node in which the
	//                       nodes will be appended
	[id(SSCLID_APPEND_NODES), helpstring("method AppendNodes")]
		HRESULT AppendNodes([in] INodes* NodeCollection, [in] BSTR Parent);

	// Description:
	//    Remove one node from the model
	// Parameters:
	//    Node  - Node to remove
	[id(SSCLID_DELETE_NODE), helpstring("method DeleteNode")]
		HRESULT DeleteNode([in] INode* Node);

	// Description:
	//    Remove one or more nodes from the model
	// Parameters:
	//    NodeCollection  - List of nodes to remove
	[id(SSCLID_DELETE_NODES), helpstring("method DeleteNodes")]
		HRESULT DeleteNodes([in] INodes* NodeCollection);

	// Description:
	//    Translate one or more nodes in the model
	// Parameters:
	//    NodeCollection - List of nodes to move
	//    tx             - Distance to move in X direction
	//    ty             - Distance to move in Y direction
	//    tz             - Distance to move in Z direction
	[id(SSCLID_MOVE_NODES), helpstring("method MoveNodes")]
		HRESULT MoveNodes([in] INodes* NodeCollection,
		                  [in] VALUE3D tx,
		                  [in] VALUE3D ty,
		                  [in] VALUE3D tz);

	// Description:
	//    Scale one or more nodes in the model
	// Parameters:
	//    NodeCollection  - List of nodes to scale
	//    sx              - Percentage to scale in X direction
	//    sy              - Percentage to scale in Y direction
	//    sz              - Percentage to scale in Z direction
	[id(SSCLID_SCALE_NODES), helpstring("method ScaleNodes")]
		HRESULT ScaleNodes([in] INodes* NodeCollection,
		                   [in] VALUE3D sx,
		                   [in] VALUE3D sy,
		                   [in] VALUE3D sz);

	// Description:
	//    Rotate one or more nodes in the model
	// Parameters:
	//    NodeCollection  - List of nodes to rotate
	//    Radians         - Angle of rotation in radians
	//    AxisX           - X component of vector about which to rotate
	//    AxisY           - Y component of vector about which to rotate
	//    AxisZ           - Z component of vector about which to rotate
	[id(SSCLID_ROTATE_NODES), helpstring("method RotateNodes")]
		HRESULT RotateNodes([in] INodes* NodeCollection,
		                    [in] VALUE3D Radians,
		                    [in] VALUE3D AxisX,
		                    [in] VALUE3D AxisY,
		                    [in] VALUE3D AxisZ);

	// Description:
	//    Group one or more nodes together into a single node
	// Parameters:
	//    Group          - Group node into which nodes will be grouped
	//    NodeCollection - List of nodes to add to group
	[id(SSCLID_GROUP_NODES), helpstring("method GroupNodes")]
		HRESULT GroupNodes([in] INode* Group,
		                   [in] INodes* NodeCollection);

	// Description:
	//    Remove a group.
	// Parameters:
	//    Group          - Group node to break up
	//    NodeCollection - List of nodes removed from the group node
	[id(SSCLID_UNGROUP_NODES), helpstring("method UngroupNodes")]
		HRESULT UngroupNodes([in] INode* Group,
		                     [in] INodes* NodeCollection);

	// Description:
	//    BSP (binary space partitioning) tree owned by the model
	// See Also:
	//    IBSPTree
	[propget, id(SSCLID_BSPTREE), helpstring("property BSPTree")]
		HRESULT BSPTree([out, retval] IBSPTree** BSPTree);

	[propget, id(SSCLID_BSPTREE_ENABLED), helpstring("property BSPTreeEnabled")]
		HRESULT BSPTreeEnabled([out, retval] VARIANT_BOOL* pVal);

	// Description:
	//    Flag that indicates whether BSP tree should be used for hit testing or not.
	[propput, id(SSCLID_BSPTREE_ENABLED), helpstring("property BSPTreeEnabled")]
		HRESULT BSPTreeEnabled([in] VARIANT_BOOL newVal);

	// Description:
	//    Loads all nodes in the model into the BSP tree.
	[id(SSCLID_LOAD_BSPTREE), helpstring("method LoadBSPTree")]
		HRESULT LoadBSPTree();

	// Description:
	//    Enable or disable firing of events from the model.
	// Parameters:
	//    Flag   - Pass TRUE to disable events and FALSE to enable
	// Remarks:
	//    The number of locks is incremented when this function is
	//    passed TRUE and decremented when it is passed FALSE. If the
	//    number of locks is greater than zero, firing of events is
	//    disabled.
	[id(SSCLID_LOCK_EVENTS), helpstring("method LockEvents")]
		HRESULT LockEvents([in] VARIANT_BOOL Flag);
};

[
	object,
	uuid(0D8DEE05-B1C4-4a7d-9A41-3FA6FE060563),
	dual,
	helpstring("IModelReader Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Loads a model from a given data source.
//
// Remarks:
//    There is a different implementation of this interface for each
//    supported 3D graphics file format (3DS, DXF, .X, etc.)
//
// See Also:
//    IModel, IModelWriter
////////////////////////////////////////////////////////////////////////////
interface IModelReader : IDispatch
{
	// Description:
	//    Load a model from a given data source
	// Parameters:
	//    DataSource - Name of file to read
	//    Model      - Model to load file into
	[id(SSCLID_READ), helpstring("method Read")]
		HRESULT Read([in] VARIANT DataSource,
		             [in] IModel* Model);
};

[
	object,
	uuid(B8265913-CCAB-451c-8D8C-0E39FB16CC61),
	dual,
	helpstring("IModelWriter Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Writes a model from a given data source.
//
// Remarks:
//    There is a different implementation of this interface for each
//    supported 3D graphics file format (3DS, DXF, .X, etc.)
//
// See Also:
//    IModel, IModelReader
////////////////////////////////////////////////////////////////////////////
interface IModelWriter : IDispatch
{
	// Description:
	//    Write a model to a data source
	// Parameters:
	//    DataSource  - Name of file to write
	//    Model       - Model to write
	[id(SSCLID_WRITE), helpstring("method Write")]
		HRESULT Write([in] VARIANT DataSource, [in] IModel* Model);
};

[
	object,
	uuid(4FC1A80D-2F7A-4719-BDC3-FBCD376F3866),
	dual,
	helpstring("IVisual2D Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Interface to 2D visual objects.
//
// Remarks:
//    Viewports are an example of 2D visual objects that implement this
//    interface. Viewports can also contain 2D child objects, which
//    can be used to decorate the viewport. One example of a 2D child
//    object are crosshairs.
//
// See Also:
//    IViewport, ICompositeNode
////////////////////////////////////////////////////////////////////////////
interface IVisual2D : ICompositeNode
{
	// Description:
	//    Left edge of the visual object's bounding rectangle
	[propget, id(SSCLID_LEFT), helpstring("property Left")]
		HRESULT Left([out, retval] long *pVal);

	[propput, id(SSCLID_LEFT), helpstring("property Left")]
		HRESULT Left([in] long newVal);

	// Description:
	//    Top edge of the visual object's bounding rectangle
	[propget, id(SSCLID_TOP), helpstring("property Top")]
		HRESULT Top([out, retval] long *pVal);

	[propput, id(SSCLID_TOP), helpstring("property Top")]
		HRESULT Top([in] long newVal);

	// Description:
	//    Width of the visual object's bounding rectangle
	[propget, id(SSCLID_WIDTH), helpstring("property Width")]
		HRESULT Width([out, retval] long *pVal);

	[propput, id(SSCLID_WIDTH), helpstring("property Width")]
		HRESULT Width([in] long newVal);

	// Description:
	//    Height of the visual object's bounding rectangle
	[propget, id(SSCLID_HEIGHT), helpstring("property Height")]
		HRESULT Height([out, retval] long *pVal);

	[propput, id(SSCLID_HEIGHT), helpstring("property Height")]
		HRESULT Height([in] long newVal);

	// Description:
	//    Sets the object's bounding rectangle
	// Parameters:
	//    pBounds  - Rectangle that defines the bounds of the object
	HRESULT SetBounds([in] LPRECT pBounds);
};

[
	object,
	uuid(F972773C-92A9-493e-8820-CD9483327E88),
	dual,
	helpstring("ICamera Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Interface to a camera node. A camera defines the point of view
//    used to render a viewport.
//
// Remarks:
//    A camera defines a point of view used to render a model into a
//    viewport. The camera's orientation is defined by its location and
//    two vectors. The first vector determines the direction the camera
//    is facing. The second vector determines which way is up.
//
// See Also:
//    INode, IViewport
////////////////////////////////////////////////////////////////////////////
interface ICamera : INode
{
	// Description:
	//    Set the location of the camera
	// Parameters:
	//    x   - X component of the point that specifies the camera's location
	//    y   - Y component of the point that specifies the camera's location
	//    z   - Z component of the point that specifies the camera's location
	[id(SSCLID_SET_LOCATION), helpstring("method SetLocation")]
		HRESULT SetLocation([in] VALUE3D x, [in] VALUE3D y, [in] VALUE3D z);

	// Description:
	//    Get the location of the camera
	// Parameters:
	//    x  - Receives the X component of the camera's location
	//    y  - Receives the Y component of the camera's location
	//    z  - Receives the Z component of the camera's location
	[id(SSCLID_GET_LOCATION), helpstring("method GetLocation")]
		HRESULT GetLocation([out] VALUE3D* x, [out] VALUE3D* y, [out] VALUE3D* z);

	// Description:
	//    Set the vector that determines the direction the camera is facing
	// Parameters:
	//    x  - X component of the aim vector
	//    y  - Y component of the aim vector
	//    z  - Z component of the aim vector
	[id(SSCLID_SET_AIMVECTOR), helpstring("method SetAimVector")]
		HRESULT SetAimVector([in] VALUE3D x, [in] VALUE3D y, [in] VALUE3D z);

	// Description:
	//    Get the vector that determines the direction the camera is facing
	// Parameters:
	//    x  - Receives the X component of the aim vector
	//    y  - Receives the Y component of the aim vector
	//    z  - Receives the Z component of the aim vector
	[id(SSCLID_GET_AIMVECTOR), helpstring("method GetAimVector")]
		HRESULT GetAimVector([out] VALUE3D* px, [out] VALUE3D* py, [out] VALUE3D* pz);

	// Description:
	//    Set the vector that determines the orientation of the top of the camera
	// Parameters:
	//    x  - X component of the up vector
	//    y  - Y component of the up vector
	//    z  - Z component of the up vector
	[id(SSCLID_SET_UPVECTOR), helpstring("method SetUpVector")]
		HRESULT SetUpVector([in] VALUE3D x, [in] VALUE3D y, [in] VALUE3D z);

	// Description:
	//    Get the vector that determines the orientation of the top of the camera
	// Parameters:
	//    px  - Receives the X component of the up vector
	//    py  - Receives the Y component of the up vector
	//    pz  - Receives the Z component of the up vector
	[id(SSCLID_GET_UPVECTOR), helpstring("method GetUpVector")]
		HRESULT GetUpVector([out] VALUE3D* px, [out] VALUE3D* py, [out] VALUE3D* pz);

	// Description:
	//    Aims the camera at a given point
	// Parameters:
	//    x  - X component of the point to aim the camera at
	//    y  - Y component of the point to aim the camera at
	//    z  - Z component of the point to aim the camera at
	// Remarks:
	//    This function sets the camera's aim vector using a point
	[id(SSCLID_POINTAT), helpstring("method PointAt")]
		HRESULT PointAt([in] VALUE3D x, [in] VALUE3D y, [in] VALUE3D z);

	// Description:
	//    Moves the camera to a new location
	// Parameters:
	//    MoveType  - Specifies the type of movement
	//    Amount    - Specifies the distance to move the camera
	// See Also:
	//    CameraMovement
	[id(SSCLID_MOVE), helpstring("method Move")]
		HRESULT Move([in] enum CameraMovement MoveType, [in] VALUE3D Amount);

	// Description:
	//    Moves the camera to a new location
	// Parameters:
	//    dx   - Distance to move in X direction
	//    dy   - Distance to move in Y direction
	//    dz   - Distance to move in Z direction
	[id(SSCLID_TRANSLATE), helpstring("method Translate")]
		HRESULT Translate([in] VALUE3D dx, [in] VALUE3D dy, [in] VALUE3D dz);

	// Description:
	//    Rotates the camera
	// Parameters:
	//    fXRadians  - Number of degrees in radians to rotate around the
	//                 X axis of the camera
	//    fYRadians  - Number of degrees in radians to rotate around the
	//                 Y axis of the camera
	//    fZRadians  - Number of degrees in radians to rotate around the
	//                 Z axis of the camera
	[id(SSCLID_ROTATE), helpstring("method Rotate")]
		HRESULT Rotate([in] VALUE3D fXRadians,
			           [in] VALUE3D fYRadians,
			           [in] VALUE3D fZRadians);
};

[
	object,
	uuid(96FD479D-0993-4172-BA6F-3223BC45332C),
	dual,
	helpstring("IViewport Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    A viewport renders a model onto a device.
//
// Remarks:
//    A viewport can be either windowed or full-screen. It is attached to
//    a particular device and renders a model onto that device.
//
// See Also:
//    IVisual2D, IModel
////////////////////////////////////////////////////////////////////////////
interface IViewport : IVisual2D
{
	// Description:
	//    This function is called automatically by the framework to initialize
	//    the viewport. Users should not call this function.
	// Parameters:
	//    Device  - Device the viewport will be attached to
	[id(SSCLID_INITOBJECT), hidden, helpstring("property _InitObject")]
		HRESULT _InitObject([in] IDevice* Device);

	// Description:
	//    The device that the viewport is rendered on.
	// Remarks:
	//    Viewports are created through the IDevice::CreateDevice method.
	[propget, id(SSCLID_DEVICE), helpstring("property Device")]
		HRESULT Device([out, retval] IDevice** Device);

	// Description:
	//    Flag that indicates if the viewport is full-screen or windowed.
	[propget, id(SSCLID_WINDOWED), helpstring("property Windowed")]
		HRESULT Windowed([out, retval] VARIANT_BOOL *pVal);

	[propput, id(SSCLID_WINDOWED), helpstring("property Windowed")]
		HRESULT Windowed([in] VARIANT_BOOL newVal);

	// Description:
	//    Window that owns the viewport
	[propget, id(SSCLID_CONTAINERWINDOW), helpstring("property ContainerWindow")]
		HRESULT ContainerWindow([out, retval] long *pVal);

	[propput, id(SSCLID_CONTAINERWINDOW), helpstring("property ContainerWindow")]
		HRESULT ContainerWindow([in] long newVal);

	// Description:
	//    Boolean flag to control whether container window is automatically
	//    invalidated when the viewport is rendered.
	[propget, id(SSCLID_INVALIDATE_WINDOW), helpstring("property InvalidateWindow")]
		HRESULT InvalidateWindow([out, retval] VARIANT_BOOL *pVal);

	[propput, id(SSCLID_INVALIDATE_WINDOW), helpstring("property InvalidateWindow")]
		HRESULT InvalidateWindow([in] VARIANT_BOOL newVal);

	// Description:
	//    Each viewport is associated with a model. The model renders itself
	//    onto the viewport.
	[propget, id(SSCLID_MODEL), helpstring("property Model")]
		HRESULT Model([out,retval] IModel** ppVal);

	[propputref, id(SSCLID_MODEL), helpstring("property Model")]
		HRESULT Model([in] IModel* pNewVal);

	// Description:
	//    The rendering context contains ID/value pairs that provide the
	//    rendering engine with special instructions.
	// See Also:
	//    IRenderingContext, RenderStateType
	[propget, id(SSCLID_CONTEXT), helpstring("property Context")]
		HRESULT Context([out,retval] IRenderingContext** ppVal);

	[propputref, id(SSCLID_CONTEXT), helpstring("property Context")]
		HRESULT Context([in] IRenderingContext* pNewVal);

	// Description:
	//    Each viewport has one camera that is used to determine the
	//    point of view during rendering. The camera can be moved around
	//    the scene in order to navigate the model.
	[propget, id(SSCLID_CAMERA), helpstring("property Camera")]
		HRESULT Camera([out,retval] ICamera** ppVal);

	[propputref, id(SSCLID_CAMERA), helpstring("property Camera")]
		HRESULT Camera([in] ICamera* pNewVal);

	// Description:
	//    Renders the viewport into a buffer on the device.
	[id(SSCLID_RENDER), helpstring("method Render")]
		HRESULT Render();

	// Description:
	//    Updates the screen with the contents of the device's buffer.
	[id(SSCLID_REFRESHSCREEN), helpstring("method RefreshScreen")]
		HRESULT RefreshScreen();

	// Description:
	//    Invalidates the container window and causes the screen to be
	//     refreshed.
	[id(SSCLID_INVALIDATE), helpstring("method Invalidate")]
		HRESULT Invalidate();

	// Description:
	//    Renders a list of tracking nodes used to visually represent
	//    interactive operations such as drag and drop.
	// Parameters:
	//    TrackingNodes - List of tracking nodes to draw
	// Remarks:
	//    This function is typically called by behavior objects that
	//    implement the interactive functionality.
	[id(SSCLID_DRAW_TRACKING), helpstring("method DrawTracking")]
		HRESULT DrawTracking([in] INodes* TrackingNodes);

	// Description:
	//    Attaches a list of nodes to the viewport that represents the
	//    current selection
	// Parameters:
	//    pSelectionList - Pointer to a node list
	// Remarks:
	//    This function is typically called by controllers in order to
	//    provide the viewport with the list of currently selected nodes.
	//    The controller owns the selection list and shares it with the
	//    viewport so that the viewport can highlight the selected nodes
	//    during rendering.
	[id(SSCLID_SET_SELECTIONLIST), helpstring("method SetSelectionList")]
		HRESULT SetSelectionList([in] INodes* pSelectionList);

	// Description:
	//    Convert a screen point (pixel) into world coordinates.
	// Parameters:
	//    ScreenX      - X component of the screen point
	//    ScreenY      - Y component of the screen point
	//    RayOrigin    - Receives a POINT3D structure that contains the
	//                   origin of the ray
	//    RayDirection - Receives a VECTOR3D structure
	// Remarks:
	//    Converting a screen point into world coordinates results in a
	//    ray that is projected from the screen through the scene. In other
	//    words, a screen point maps onto an infinite number of points along
	//    a ray.
	[id(SSCLID_SCREENTOWORLD), helpstring("method ScreenToWorld")]
		HRESULT ScreenToWorld([in] int ScreenX, [in] int ScreenY,
		                      [out] VARIANT* RayOrigin,
		                      [out] VARIANT* RayDirection);

	// Description:
	//    Convert a world point into screen coordinates.
	// Parameters:
	//    WorldPoint  - POINT3D structure containing world point
	//    ScreenX     - Receives X component of the screen coordinate
	//    ScreenY     - Receives Y component of the screen coordinate
	[id(SSCLID_WORLDTOSCREEN), helpstring("method WorldToScreen")]
		HRESULT WorldToScreen([in] VARIANT WorldPoint,
		                      [out] int* ScreenX, [out] int* ScreenY);

	// Description:
	//    Set the frustum (viewing volume) of the viewport
	// Parameters:
	//    FOV       - Field of view angle in radians
	//    Aspect    - Aspect ratio of viewport (ratio of width to height)
	//    NearPlane - Distance of the near plane from the camera
	//    FarPlane  - Distance of the far plane from the camera
	// Remarks:
	//    The frustum values are used to setup the projection matrix.
	//    The projection matrix determines how the viewer sees the contents
	//    of the model. The frustum is similar to the lens of a camera.
	[id(SSCLID_SET_FRUSTUM), helpstring("method SetFrustum")]
		HRESULT SetFrustum([in] FLOAT FOV,
			               [in] FLOAT Aspect,
			               [in] FLOAT NearPlane,
			               [in] FLOAT FarPlane);

	// Description:
	//    Get the frustum (viewing volume) of the viewport.
	// Parameters:
	//    FOV       - Receives the field of view angle in radians
	//    Aspect    - Receives the aspect ratio of the viewport
	//    NearPlane - Receives the near plane value
	//    FarPlane  - Receives the far plane value
	// Remarks:
	//    The frustum values are used to setup the projection matrix.
	//    The projection matrix determines how the viewer sees the contents
	//    of the model. The frustum is similar to the lens of a camera.
	[id(SSCLID_GET_FRUSTUM), helpstring("method GetFrustum")]
		HRESULT GetFrustum([out] FLOAT* FOV,
			               [out] FLOAT* Aspect,
			               [out] FLOAT* NearPlane,
			               [out] FLOAT* FarPlane);

	// Description:
	//    Calculate the distance from the camera to a given point.
	// Parameters:
	//    x        - X component of point
	//    y        - Y component of point
	//    z        - Z component of point
	//    Distance - Receives distance to point from the camera
	[id(SSCLID_DISTANCETOPOINT), helpstring("method DistanceToPoint")]
		HRESULT DistanceToPoint([in] VALUE3D x,
			                    [in] VALUE3D y,
			                    [in] VALUE3D z,
			                    [out,retval] VALUE3D* Distance);

	// Description:
	//    Set the background color of the viewport
	// Parameters:
	//    Red     - Red component of background color
	//    Green   - Green component of background color
	//    Blue    - Blue component of background color
	//    Alpha   - Alpha transparency value
	[id(SSCLID_SET_BACKGROUNDCOLOR), helpstring("method SetBackgroundColor")]
		HRESULT SetBackgroundColor([in] VALUE3D Red,
			                       [in] VALUE3D Green,
			                       [in] VALUE3D Blue,
			                       [in] VALUE3D Alpha);

	// Description:
	//    Get the background color of the viewport
	// Parameters:
	//    Red      - Receives the red component of the background color
	//    Green    - Receives the green component of the background color
	//    Blue     - Receives the blue component of the background color
	//    Alpha    - Receives the alpha transparency value
	[id(SSCLID_GET_BACKGROUNDCOLOR), helpstring("method GetBackgroundColor")]
		HRESULT GetBackgroundColor([in] VALUE3D* Red,
			                       [in] VALUE3D* Green,
			                       [in] VALUE3D* Blue,
			                       [in] VALUE3D* Alpha);
};

[
	object,
	uuid(637AB736-6334-4535-BADF-435FA3B08000),
	helpstring("IAxisGuide Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Interface to the axis guide viewport decorator. The axis guide
//
// Remarks:
//    The axis guide is a visual object that renders the world X, Y, and Z
//    axis in a viewport. It is a viewport decorator, which is a visual
//    object rendered by the viewport on top of the model that provides
//    visual reference information to the user. The axis guide provides
//    a visual cue to help orient the user in a scene.
//
// See Also:
//    AxisGuide
////////////////////////////////////////////////////////////////////////////
interface IAxisGuide : IVisual
{
	// Description:
	//    The length of the lines drawn to represent the axes
	[propget, id(SSCLID_AXIS_LENGTH), helpstring("property AxisLength")]
		HRESULT AxisLength([out, retval] VALUE3D* pVal);

	[propput, id(SSCLID_AXIS_LENGTH), helpstring("property AxisLength")]
		HRESULT AxisLength([in] VALUE3D newVal);
};

[
	object,
	uuid(1BB466B0-BF48-4452-8358-A809EF33169A),
	helpstring("IAnimate Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    This interface is implemented by objects that receive animation
//    events.
//
// Remarks:
//    Objects that implement this interface can be plugged into an
//    animation loop to receive animation events.
//
// See Also:
//    IAnimationLoop
////////////////////////////////////////////////////////////////////////////
interface IAnimate : IUnknown
{
	// Description:
	//    Called by the animation loop when an animate event is fired
	// Parameters:
	//    Time       - Current time returned by timeGetTime()
	//    FirstFrame - Flag indicating if this is the first time
	//                 through the animation loop
	HRESULT Animate([in] long Time, [in] VARIANT_BOOL FirstFrame);
};

[
	object,
	uuid(E3174B19-8572-42f5-A3C9-4E88B0ED254D),
	dual,
	helpstring("IAnimationLoop Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    An animation loop acts as a timer that fires events at a precise
//    interval.
//
// Remarks:
//    The object that receives the animation events must implement the
//    IAnimate interface. The interval is specified in milliseconds.
//
// See Also:
//    IAnimate
////////////////////////////////////////////////////////////////////////////
interface IAnimationLoop : IDispatch
{
	// Description:
	//    Interval between animation events (in milliseconds)
	[propget, id(SSCLID_INTERVAL), helpstring("property Interval")]
		HRESULT Interval([out, retval] long *pVal);

	[propput, id(SSCLID_INTERVAL), helpstring("property Interval")]
		HRESULT Interval([in] long newVal);

	// Description:
	//    Boolean flag that indicates if the loop is currently running
	[propget, id(SSCLID_RUNNING), helpstring("property Running")]
		HRESULT Running([out, retval] VARIANT_BOOL *pVal);

	// Description:
	//    Adds an animator object to the loop.
	// Parameters:
	//    Animator  - Pointer to object to add
	// Remarks:
	//    An animator is any object that implements the IAnimate
	//    interface. All animator objects are notified through the
	//    IAnimate::Animate function at the given interval.
	[id(SSCLID_ADD_ANIMATOR), helpstring("method AddAnimator")]
		HRESULT AddAnimator([in] IAnimate* Animator);

	// Description:
	//    Removes an animator object from the loop.
	// Parameters:
	//    Animator  - Object to remove from animation loop
	[id(SSCLID_REMOVE_ANIMATOR), helpstring("method RemoveAnimator")]
		HRESULT RemoveAnimator([in] IAnimate* Animator);

	// Description:
	//    Starts the animation loop.
	[id(SSCLID_START), helpstring("method Start")]
		HRESULT Start();

	// Description:
	//    Fires an animation event to all animator objects. This function
	//    calls each animator object's IAnimate::Animate function.
	// Parameters:
	//    Time  - Current time as returned by timeGetTime()
	[id(SSCLID_FIRE_ANIMATION), helpstring("method FireAnimation")]
		HRESULT FireAnimation([in] long Time);

	// Description:
	//    Stops the animation loop
	[id(SSCLID_STOP), helpstring("method Stop")]
		HRESULT Stop();
};

[
	object,
	uuid(7F81CB2A-658C-41ac-952F-872011476B96),
	dual,
	helpstring("ICommand Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Interface to command objects. A command encapsulates an action
//    on a command target.
//
// Remarks:
//    The Do and Undo methods take a command target parameter, which is
//    typically an IModel.
////////////////////////////////////////////////////////////////////////////
interface ICommand : IDispatch
{
	// Description:
	//    Provides a text description of the command
	[propget, id(SSCLID_COMMAND_DESCRIPTION), helpstring("property Description")]
		HRESULT Description([out, retval] BSTR *pVal);

	// Description:
	//    Executes the command
	// Parameters:
	//    CmdTarget  - Object that is affected by the command
	// Remarks:
	//    Classes that inherit this interface implement this function
	//    to perform an action on the CmdTarget
	[id(SSCLID_DO), helpstring("method Do")]
		HRESULT Do([in] INode* CmdTarget);

	// Description:
	//    Unexecutes the command and restores the command target to the
	//    state it was in prior to execution of the command
	// Parameters:
	//    CmdTarget  - Object that is affected by the command
	[id(SSCLID_UNDO), helpstring("method Undo")]
		HRESULT Undo([in] INode* CmdTarget);
};

[
	object,
	uuid(C972794F-A7FC-487f-9B8B-D4B22FDB1FCB),
	dual,
	helpstring("INodeCommand Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Interface to commands that operate on one or more nodes.
//
// Remarks:
//    This interface provides methods for adding nodes to be
//    processed by the command.
//
// See Also:
//    ICommand
////////////////////////////////////////////////////////////////////////////
interface INodeCommand : ICommand
{
	// Description:
	//    Adds a node to the command
	// Parameters:
	//    Node   - Pointer to node to add to the command
	[id(SSCLID_ADD_NODE), helpstring("method AddNode")]
		HRESULT AddNode([in] INode* Node);

	// Description:
	//    Adds a list of nodes to the command
	// Parameters:
	//    NodeCollection - List of nodes to add to the command
	[id(SSCLID_ADD_NODES), helpstring("method AddNodes")]
		HRESULT AddNodes([in] INodes* NodeCollection);
};

[
	object,
	uuid(96866B07-E5EE-43d9-B63A-10649A8A85CC),
	dual,
	helpstring("ICreateCommand Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Interface to a create command.
//
// See Also:
//    CreateCommand
////////////////////////////////////////////////////////////////////////////
interface ICreateCommand : ICommand
{
	// Description:
	//    Set the name of the new node.
	// Parameters:
	//    NodeName   - Name of the node to create
	[id(SSCLID_SET_NODE_NAME), helpstring("method SetNodeName")]
		HRESULT SetNodeName([in] BSTR NodeName);

	// Description:
	//    Set the type of the new node using a ProgId.
	// Parameters:
	//    ProgId  - ProgId of the COM class to create
	[id(SSCLID_SET_NODE_TYPE), helpstring("method SetNodeType")]
		HRESULT SetNodeType([in] BSTR ProgId);

	// Description:
	//    Set the name of the node that will be the new node's parent.
	// Parameters:
	//    Parent  - Fully qualified name of the node that will be the
	//              parent of the new node
	[id(SSCLID_SET_PARENT), helpstring("method SetParent")]
		HRESULT SetParent([in] BSTR Parent);

	// Description:
	//    Node created by the command. This property is only valid after
	//    successfully executing the create command.
	[propget, id(SSCLID_NODE), helpstring("property Node")]
		HRESULT Node([out,retval] INode** Node);
};

[
	object,
	uuid(27A0542D-B408-473b-94C9-20778313F974),
	dual,
	helpstring("ICreateShapeCommand Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Interface to a create shape command.
//
// See Also:
//    CreateShapeCommand
////////////////////////////////////////////////////////////////////////////
interface ICreateShapeCommand : ICreateCommand
{
	// Description:
	//    Set the name of the mesh to assign to the new shape.
	[id(SSCLID_SET_MESH_NAME), helpstring("method SetMeshName")]
		HRESULT SetMeshName([in] BSTR MeshName);
};

[
	object,
	uuid(5DDC2A0F-192F-4cb0-88CB-B940066C4C33),
	dual,
	helpstring("IInsertCommand Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Interface to an insert command. The insert command adds one or more
//    nodes to a model.
//
// Remarks:
//    The nodes to be inserted into the model are attached to the command
//    through the INodeCommand interface.
//
// See Also:
//    InsertCommand
////////////////////////////////////////////////////////////////////////////
interface IInsertCommand : INodeCommand
{
	// Description:
	//    Set the name of the node that will own the nodes inserted.
	// Parameters:
	//    Parent  - Name of node that will be the parent of the newly
	//              inserted node(s).
	[id(SSCLID_SET_PARENT), helpstring("method SetParent")]
		HRESULT SetParent([in] BSTR Parent);
};

[
	object,
	uuid(E8F3400B-3F4D-497d-AEDE-667D5639B8EC),
	dual,
	helpstring("IMoveCommand Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Interface to a move command. A move command translates one or
//    more nodes.
//
// Remarks:
//    The nodes to be moved are attached to the command through the
//    INodeCommand interface.
//
// See Also:
//    MoveCommand
////////////////////////////////////////////////////////////////////////////
interface IMoveCommand : INodeCommand
{
	// Description:
	//    Sets the move vector
	// Parameters:
	//    tx   - X component of the move vector
	//    ty   - Y component of the move vector
	//    tz   - Z component of the move vector
	[id(SSCLID_SET_DELTA), helpstring("method SetDelta")]
		HRESULT SetDelta([in] VALUE3D tx, [in] VALUE3D ty, [in] VALUE3D tz);
};

[
	object,
	uuid(F8EA3F09-31B8-49fb-812E-41381EE2CF5B),
	dual,
	helpstring("IRotateCommand Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Interface to a rotate command. A rotate command rotates one or more
//    nodes around a given axis vector.
//
// Remarks:
//    The nodes to be moved are attached to the command through the
//    INodeCommand interface. Rotation in 3D occurs around a ray. The
//    rotate command uses a vector, referred to as the axis, that projects
//    from origin of the object. The origin of the object along with the
//    axis vector provide the ray needed as an anchor for the rotation.
//    The IRotateCommand::SetAxis function is used to set the axis vector
//    for the rotation.
//
// See Also:
//    INodeCommand, RotateCommand
////////////////////////////////////////////////////////////////////////////
interface IRotateCommand : INodeCommand
{
	// Description:
	//    Sets the angle of rotation in radians
	// Parameters:
	//    Radians   - Angle of rotation
	[id(SSCLID_SET_ANGLE), helpstring("method SetAngle")]
		HRESULT SetAngle([in] VALUE3D Radians);

	// Description:
	//    Sets the vector about which the rotation will occur
	// Parameters:
	//    AxisX    - X component of vector
	//    AxisY    - Y component of vector
	//    AxisZ    - Z component of vector
	// Remarks:
	//    The axis vector in combination with the origin produce a ray
	//    about which the rotation will occur.
	[id(SSCLID_SET_AXIS), helpstring("method SetAxis")]
		HRESULT SetAxis([in] VALUE3D AxisX,
		                [in] VALUE3D AxisY,
		                [in] VALUE3D AxisZ);
};

[
	object,
	uuid(42D06C74-4112-41eb-8775-E4C52DF3B370),
	dual,
	helpstring("IScaleCommand Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Interface to a scale command. A scale command scales one or more
//    nodes in one or more directions.
//
// Remarks:
//    The nodes to be moved are attached to the command through the
//    INodeCommand interface.
//
// See Also:
//    INodeCommand, ScaleCommand
////////////////////////////////////////////////////////////////////////////
interface IScaleCommand : INodeCommand
{
	// Description:
	//    Sets the scaling percentage for each axis
	// Parameters:
	//    sx   - Percentage to scale the X axis
	//    sy   - Percentage to scale the Y axis
	//    sz   - Percentage to scale the Z axis
	[id(SSCLID_SET_SCALE), helpstring("method SetScale")]
		HRESULT SetScale([in] VALUE3D sx, [in] VALUE3D sy, [in] VALUE3D sz);
};

[
	object,
	uuid(15F00CCC-3E0F-431a-9303-37CDC6FD4801),
	dual,
	helpstring("IGroupCommand Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Interface to a group command. A group command combines several nodes
//    into a single group node.
//
// Remarks:
//    This command creates a new Group object and adds the nodes to it.
//
// See Also:
//    INodeCommand, GroupCommand, Group
////////////////////////////////////////////////////////////////////////////
interface IGroupCommand : INodeCommand
{
	// Description:
	//    Set the name of the node that will own the new group.
	// Parameters:
	//    Parent  - Fully qualified name of the node that will be the
	//              parent of the new group
	[id(SSCLID_SET_PARENT), helpstring("method SetParent")]
		HRESULT SetParent([in] BSTR Parent);

	// Description:
	//    Set the name of the new group node.
	// Parameters:
	//    Name to assign to the new group node
	[id(SSCLID_SET_NODE_NAME), helpstring("method SetNodeName")]
		HRESULT SetNodeName([in] BSTR NodeName);
};

[
	object,
	uuid(AF40D650-4505-4a1a-9411-2C163BB16C08),
	dual,
	helpstring("IUngroupCommand Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Interface to an ungroup command. An ungroup command disbands a
//    Group object and moves all of the nodes in the group to the group
//    node's parent.
//
// See Also:
//    INodeCommand, UngroupCommand
////////////////////////////////////////////////////////////////////////////
interface IUngroupCommand : ICommand
{
	// Description:
	//    Set the name of the group to remove.
	// Parameters:
	//    NodeName  - Fully qualified name of the group node to remove
	[id(SSCLID_SET_NODE_NAME), helpstring("method SetNodeName")]
		HRESULT SetNodeName([in] BSTR NodeName);
};

[
	object,
	uuid(2BB7249B-167C-438f-85CD-6128305D4F6D),
	dual,
	helpstring("IMacroCommand Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    A macro command aggregates other commands into a single command.
//
// Remarks:
//    A macro command contains a list of other commands. When the macro
//    is executed, each command in the list is executed.
//
// See Also:
//    ICommand, MacroCommand
////////////////////////////////////////////////////////////////////////////
interface IMacroCommand : ICommand
{
	// Description:
	//    Adds a command to the macro
	// Parameters:
	//    Command  - Command to add to the list
	// Remarks:
	//    This function appends the command to the macro's list. Commands
	//    in the macro are executed in the order that they are added.
	[id(SSCLID_ADD_COMMAND), helpstring("method AddCommand")]
		HRESULT AddCommand([in] ICommand* Command);

	// Description:
	//    Removes all commands from the macro. This function clears the
	//    macro.
	[id(SSCLID_CLEAR_COMMANDS), helpstring("method ClearCommands")]
		HRESULT ClearCommands();

	// Description:
	//    The number of commands in the macro
	// Parameters:
	//    pVal - Receives the number of commands in the macro
	[propget, id(SSCLID_COMMAND_COUNT), helpstring("property CommandCount")]
		HRESULT CommandCount([out, retval] long* pVal);
};

[
	object,
	uuid(DA12B66A-6935-4774-BB1B-4959FE4B58E3),
	dual,
	helpstring("ICommandDispatcher Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    This interface provides methods for dispatching commands. A command
//    dispatcher executes commands and manages undo and redo stacks.
//
// Remarks:
//    This interface is inherited by IController which gives controllers
//    the ability to execute and track commands.
//
// See Also:
//    ICommand, IController
////////////////////////////////////////////////////////////////////////////
interface ICommandDispatcher : IDispatch
{
	// Description:
	//    Maximum number of commands that can be stored in the undo and
	//    redo buffers. The default value is 100. When either the undo
	//    or redo buffers reach this limit, the oldest command in the
	//    buffer is purged.
	[propget, id(SSCLID_MAX_HISTORY), helpstring("property MaxHistory")]
		HRESULT MaxHistory([out, retval] long* pVal);

	[propput, id(SSCLID_MAX_HISTORY), helpstring("property MaxHistory")]
		HRESULT MaxHistory([in] long newVal);

	// Description:
	//    The number of commands currently in the undo buffer
	[propget, id(SSCLID_UNDO_COUNT), helpstring("property UndoCount")]
		HRESULT UndoCount([out, retval] long* pVal);

	// Description:
	//    The number of commands currently in the redo buffer
	[propget, id(SSCLID_REDO_COUNT), helpstring("property RedoCount")]
		HRESULT RedoCount([out, retval] long* pVal);

	// Description:
	//    Executes the given command and pushes it onto the undo stack
	// Parameters:
	//    Command  - Command to execute
	[id(SSCLID_DO), helpstring("method Do")]
		HRESULT Do([in] ICommand* Command);

	// Description:
	//    Pops the given number of commands from the undo stack and
	//    unexecutes them by calling ICommand::Undo for each command
	//    popped from the stack. Each command is then pushed onto the
	//    redo stack.
	// Parameters:
	//    NumCommands - Number of commands to pop from the undo stack
	[id(SSCLID_UNDO), helpstring("method Undo")]
		HRESULT Undo([in] long NumCommands);

	// Description:
	//    Pops the given number of commands from the redo stack and
	//    executes them by calling ICommand::Do for each command
	//    popped from the stack. Each command is then pushed onto the
	//    undo stack.
	// Parameters:
	//    NumCommands - Number of commands to pop from the redo stack
	[id(SSCLID_REDO), helpstring("method Redo")]
		HRESULT Redo([in] long NumCommands);

	// Description:
	//    Returns the command on the undo stack at the given position
	// Parameters:
	//    StackOffset - Offset into the undo stack where 0 refers to the
	//                  command on the top of the stack
	//    Command     - Output parameter to receive a reference to the
	//                  command
	// Remarks:
	//    This function provides a way to examine the entire undo stack.
	//    This is useful for implementing an undo/redo user interface that
	//    provides a descriptive list of commands to the user that are
	//    on the undo/redo stacks.
	[id(SSCLID_PEEKUNDO), helpstring("method PeekUndo")]
		HRESULT PeekUndo([in] long StackOffset, [out,retval] ICommand** Command);

	// Description:
	//    Returns the command on the redo stack at the given position
	// Parameters:
	//    StackOffset - Offset into the redo stack where 0 refers to the
	//                  command on the top of the stack
	//    Command     - Output parameter to receive a reference to the
	//                  command
	// Remarks:
	//    This function provides a way to examine the entire redo stack.
	//    This is useful for implementing an undo/redo user interface that
	//    provides a descriptive list of commands to the user that are
	//    on the undo/redo stacks.
	[id(SSCLID_PEEKREDO), helpstring("method PeekRedo")]
		HRESULT PeekRedo([in] long StackOffset, [out,retval] ICommand** Command);

	// Description:
	//    Removes all commands from the undo and redo stacks.
	[id(SSCLID_CLEAR_HISTORY), helpstring("method ClearHistory")]
		HRESULT ClearHistory();
};

[
	object,
	uuid(A46CDB96-4C8D-48bd-8839-931D2621CEFD),
	dual,
	helpstring("IBehavior Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Behaviors are named objects that perform actions for a controller
//    based on events that it receives. A controller can have one or
//    more behaviors. 
//
// Remarks:
//    Behaviors provide a powerful way to customize the functionality of
//    a controller.
//
// See Also:
//    IController
////////////////////////////////////////////////////////////////////////////
interface IBehavior : IDispatch
{
	// Description:
	//    Attaches the behavior to a controller. Behaviors commonly
	//    access the controller to get state information and to execute
	//    commands.
	// Remarks:
	//    This function is called automatically by the controller when it
	//    creates a behavior.
	[id(SSCLID_SET_CONTROLLER), helpstring("property SetController")]
		HRESULT SetController([in] IController* Controller);

	// Description:
	//    Descriptive name of the behavior.
	[propget, id(SSCLID_NAME), helpstring("property Name")]
		HRESULT Name([out, retval] BSTR *pVal);

	// Description:
	//    Boolean flag used to enable or disable the behavior
	[propget, id(SSCLID_ENABLED), helpstring("property Enabled")]
		HRESULT Enabled([out, retval] VARIANT_BOOL *pVal);

	[propput, id(SSCLID_ENABLED), helpstring("property Enabled")]
		HRESULT Enabled([in] VARIANT_BOOL newVal);
};

[
	object,
	uuid(7C024917-40D4-4f26-A7F2-3DF00E27B712),
	dual,
	helpstring("ICameraFly Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Interface to camera fly behavior.
//
// Remarks:
//    The camera fly behavior is an animated navigation behavior that lets
//    the user move through a scene with six degrees of freedom. Forward
//    and rotational velocity can be set as a function of distance and time.
//
// See Also:
//    IController
////////////////////////////////////////////////////////////////////////////
interface ICameraFly : IBehavior
{
	// Description:
	//    Used to set the velocity of the camera movement through the scene.
	//    This property is used in combination with the VelocityTime property
	//    to calculate the velocity.
	[propget, id(SSCLID_VELOCITY_DISTANCE), helpstring("property VelocityDistance")]
		HRESULT VelocityDistance([out, retval] VALUE3D *pVal);

	[propput, id(SSCLID_VELOCITY_DISTANCE), helpstring("property VelocityDistance")]
		HRESULT VelocityDistance([in] VALUE3D newVal);

	// Description:
	//    Used to set the velocity of the camera movement through the scene.
	//    This property is used in combination with the VelocityDistance property
	//    to calculate the velocity.
	[propget, id(SSCLID_VELOCITY_TIME), helpstring("property VelocityTime")]
		HRESULT VelocityTime([out, retval] long *pVal);

	[propput, id(SSCLID_VELOCITY_TIME), helpstring("property VelocityTime")]
		HRESULT VelocityTime([in] long newVal);

	// Description:
	//    Used to set the velocity of the camera rotation. This property is
	//    used in combination with the RotateDistance property to calculate
	//    the velocity.
	[propget, id(SSCLID_ROTATE_TIME), helpstring("property RotateTime")]
		HRESULT RotateTime([out, retval] long *pVal);

	[propput, id(SSCLID_ROTATE_TIME), helpstring("property RotateTime")]
		HRESULT RotateTime([in] long newVal);

	// Description:
	//    Used to set the velocity of the camera rotation. This property is
	//    used in combination with the RotateTime property to calculate
	//    the velocity.
	[propget, id(SSCLID_ROTATE_DISTANCE), helpstring("property RotateDistance")]
		HRESULT RotateDistance([out, retval] float *pVal);

	[propput, id(SSCLID_ROTATE_DISTANCE), helpstring("property RotateDistance")]
		HRESULT RotateDistance([in] float newVal);
};

[
	object,
	uuid(B3BDC314-CB74-450a-B8E9-FB730511374C),
	dual,
	helpstring("ICameraStep Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Interface to camera step behavior.
//
// Remarks:
//    The camera step behavior is a non-animated navigation behavior that
//    lets the user incrementally step through a scene.
//
// See Also:
//    IController
////////////////////////////////////////////////////////////////////////////
interface ICameraStep : IBehavior
{
	// Description:
	//    Number of logical units to move camera when the user provides input
	//    to move through the scene.
	[propget, id(SSCLID_MOVE_INCREMENT), helpstring("property MoveIncrement")]
		HRESULT MoveIncrement([out, retval] VALUE3D *pVal);

	[propput, id(SSCLID_MOVE_INCREMENT), helpstring("property MoveIncrement")]
		HRESULT MoveIncrement([in] VALUE3D newVal);

	// Description:
	//    Number of logical units to rotate camera.
	[propget, id(SSCLID_ROTATE_INCREMENT), helpstring("property RotateIncrement")]
		HRESULT RotateIncrement([out, retval] VALUE3D *pVal);

	[propput, id(SSCLID_ROTATE_INCREMENT), helpstring("property RotateIncrement")]
		HRESULT RotateIncrement([in] VALUE3D newVal);
};

[
	object,
	uuid(F9F4635A-020F-43fc-8874-555560504F1C),
	dual,
	helpstring("ISelectNodes Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Interface to the node select behavior.
//
// Remarks:
//    This behavior allows the user to select one or more nodes using
//    the mouse.
//
// See Also:
//    IController
////////////////////////////////////////////////////////////////////////////
interface ISelectNodes : IBehavior
{
	// Description:
	//    Boolean flag indicating if multiple selection is enabled
	[propget, id(SSCLID_MULTISELECT), helpstring("property MultiSelect")]
		HRESULT MultiSelect([out, retval] VARIANT_BOOL *pVal);

	[propput, id(SSCLID_MULTISELECT), helpstring("property MultiSelect")]
		HRESULT MultiSelect([in] VARIANT_BOOL newVal);
};

[
	object,
	uuid(7CE0806C-DE84-48b8-A8F8-FAA14A8B4C0C),
	dual,
	helpstring("IMoveNodes Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Interface to the node move behavior.
//
// Remarks:
//    This behavior allows the user to drag and drop one or more nodes
//    using the mouse and keyboard.
//
// See Also:
//    IController
////////////////////////////////////////////////////////////////////////////
interface IMoveNodes : IBehavior
{
	// Description:
	//    Number of logical units to move
	[propget, id(SSCLID_MOVE_INCREMENT), helpstring("property MoveIncrement")]
		HRESULT MoveIncrement([out, retval] VALUE3D *pVal);

	[propput, id(SSCLID_MOVE_INCREMENT), helpstring("property MoveIncrement")]
		HRESULT MoveIncrement([in] VALUE3D newVal);

	// Description:
	//    Called by the application to start the process of moving the
	//    selected nodes
	[id(SSCLID_BEGIN_MOVE), helpstring("method BeginMove")]
		HRESULT BeginMove();

	// Description:
	//    Called by the application to drop the selected nodes at the
	//    location of the tracking nodes.
	[id(SSCLID_END_MOVE), helpstring("method EndMove")]
		HRESULT EndMove();

	// Description:
	//    Called by the application to cancel the move operation.
	[id(SSCLID_CANCEL_MOVE), helpstring("method CancelMove")]
		HRESULT CancelMove();
};

[
	object,
	uuid(D1C7A2E9-B59D-4ccc-8C66-7A6F649B4474),
	dual,
	helpstring("IInsertDeleteNodes Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Interface to the node insert and delete behavior.
//
// Remarks:
//    This behavior allows the user to insert and delete nodes to and from
//    the model. This behavior allows the user to drag and drop new nodes
//    into the model.
//
// See Also:
//    IController
////////////////////////////////////////////////////////////////////////////
interface IInsertDeleteNodes : IBehavior
{
	// Description:
	//    Called by the application to begin the process of inserting
	//    a new node.
	// Parameters:
	//    VisualNode - Node to insert
	//    Parent     - Fully qualified name of node that will be the
	//                 parent of the new node. NULL or empty string
	//                 if model is to be the parent.
	[id(SSCLID_INSERT_NODE), helpstring("method InsertNode")]
		HRESULT InsertNode([in] IVisual* VisualNode, [in] BSTR Parent);

	// Description:
	//    Called by the application to drop the new node at the current
	//    position of the tracker.
	[id(SSCLID_END_INSERT), helpstring("method EndInsert")]
		HRESULT EndInsert();

	// Description:
	//    Cancels an insert operation
	[id(SSCLID_CANCEL_INSERT), helpstring("method CancelInsert")]
		HRESULT CancelInsert();
};

[
	object,
	uuid(013C3E5A-2A39-41f9-AEE3-E3429272A8AB),
	dual,
	helpstring("IController Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Base interface for controllers. A controller is an object that
//    receives input from the user and translates it into actions or
//    commands on the model and viewport.
//
// Remarks:
//    A controller is similar to a state machine. A series of inputs
//    places the controller into a particular state and a given state
//    and set of inputs trigger an action.
//
// See Also:
//    BrowseController, BrowseEditController, FlightController
////////////////////////////////////////////////////////////////////////////
interface IController : ICommandDispatcher
{
	// Description:
	//    Viewport associated with the controller
	[propget, id(SSCLID_VIEWPORT), helpstring("property Viewport")]
		HRESULT Viewport([out, retval] IViewport** ppVal);

	[propputref, id(SSCLID_VIEWPORT), helpstring("property Viewport")]
		HRESULT Viewport([in] IViewport* Viewport);

	// Description:
	//    Model associated with the controller
	[propget, id(SSCLID_MODEL), helpstring("property Model")]
		HRESULT Model([out, retval] IModel** ppVal);

	// Description:
	//    List of currently selected nodes
	[propget, id(SSCLID_SELECTION_LIST), helpstring("property SelectionList")]
		HRESULT SelectionList([out, retval] INodes** ppVal);

	// Description:
	//    Keeps track of the current state of the controller. This allows
	//    behavior that is dependent on previous actions. In other words,
	//    some actions can only occur when the controller is in a certain
	//    state.
	[propget, id(SSCLID_CURRENT_STATE), helpstring("property CurrentState")]
		HRESULT CurrentState([out, retval] long* pVal);

	[propput, id(SSCLID_CURRENT_STATE), helpstring("property CurrentState")]
		HRESULT CurrentState([in] long newVal);

	// Description:
	//    Query the controller for a given behavior.
	// Parameters:
	//    Name     - Name of the behavior to retrieve
	//    Behavior - Receives the behavior
	// Remarks:
	//    Each behavior has a unique name and can be retrieved from the
	//    controller using that name. This function fails if the controller
	//    does not support the given behavior.
	[id(SSCLID_GET_BEHAVIOR), helpstring("method GetBehavior")]
		HRESULT GetBehavior([in] BSTR Name, [out,retval] IBehavior** Behavior);

	// Description:
	//    Attaches an input device to the controller
	// Parameters:
	//    InputDev   - Input device to attach
	// Remarks:
	//    The controller and its behaviors use input devices to gather user
	//    input. Input devices can be acquired from the Engine object.
	//    Each input device belongs to a category. Only one input device from
	//    a given category can be attached to the controller at a time.
	[id(SSCLID_ATTACH_INPUT_DEVICE), helpstring("method AttachInputDevice")]
		HRESULT AttachInputDevice([in] IInputDevice* InputDev);

	// Description:
	//    Removes an input device from the controller.
	// Parameters:
	//    devType   - Category of input device to remove
	// Remarks:
	//    Each input device belongs to a category. Only one input device from
	//    a given category can be attached to the controller at a time.
	[id(SSCLID_DETACH_INPUT_DEVICE), helpstring("method DetachInputDevice")]
		HRESULT DetachInputDevice([in] enum InputDeviceCategory devType);

	// Description:
	//    Moves the camera attached to the viewport
	// Parameters:
	//    MoveType   - Direction of movement
	//    Amount     - Distance to move camera
	[id(SSCLID_MOVE_CAMERA), helpstring("method MoveCamera")]
		HRESULT MoveCamera([in] enum CameraMovement MoveType,
		                   [in] VALUE3D Amount);

	// Description:
	//    Moves the camera attached to the viewport
	// Parameters:
	//    dx   - X component of the translate vector
	//    dy   - Y component of the translate vector
	//    dz   - Z component of the translate vector
	// Remarks:
	//    Moves the camera given a translate vector
	[id(SSCLID_TRANSLATE_CAMERA), helpstring("method TranslateCamera")]
		HRESULT TranslateCamera([in] VALUE3D dx, [in] VALUE3D dy, [in] VALUE3D dz);

	// Description:
	//    Rotates the camera
	// Parameters:
	//    fXRadians  - Angle to rotate about the camera's X axis in radians
	//    fYRadians  - Angle to rotate about the camera's Y axis in radians
	//    fZRadians  - Angle to rotate about the camera's Z axis in radians
	[id(SSCLID_ROTATE_CAMERA), helpstring("method RotateCamera")]
		HRESULT RotateCamera([in] VALUE3D fXRadians,
		                     [in] VALUE3D fYRadians,
		                     [in] VALUE3D fZRadians);

	// Description:
	//    Notifies the controller of an update to either the model or viewport
	// Parameters:
	//    UpdateFlags     - Code that indicates the type of update that has occurred
	//    NodesAffected   - List of nodes affected by the change
	// Remarks:
	//    This function is typically invoked by behaviors when they make a
	//    change that requires the viewport to render a new frame
	[id(SSCLID_UPDATE), helpstring("method Update")]
		HRESULT Update([in] long UpdateFlags, [in] INodes* NodesAffected);
};

[
	object,
	uuid(D761E736-0660-44cf-A3F7-14DF803A475C),
	dual,
	helpstring("IFirstPersonController Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Interface to a first person controller.
//
// Remarks:
//    A first person controller allows the user to navigate the scene
//    from a first person point of view. Collisions with the first person
//    reference point can be detected and cause an event to be fired.
//
// See Also:
//    BrowseController, BrowseEditController, FlightController
////////////////////////////////////////////////////////////////////////////
interface IFirstPersonController : IController
{
	// Description:
	//    Boolean flag that indicates if collisions are enabled or not
	[propget, id(SSCLID_COLLISIONS_ENABLED), helpstring("property CollisionsEnabled")]
		HRESULT CollisionsEnabled([out, retval] VARIANT_BOOL* pVal);

	[propput, id(SSCLID_COLLISIONS_ENABLED), helpstring("property CollisionsEnabled")]
		HRESULT CollisionsEnabled([in] VARIANT_BOOL newVal);
};

[
	object,
	uuid(4DFF8BCF-1F8A-4047-AA37-9F8E03F415F5),
	dual,
	helpstring("IEngine Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Interface to the engine object.
//
// Remarks:
//    The engine is responsible for initializing the DirectX engine and
//    takes care of managing devices.
//
// See Also:
//    Engine, Device
////////////////////////////////////////////////////////////////////////////
interface IEngine : IDispatch
{
	// Description:
	//    Initializes the engine.
	// Remarks:
	//    This function must be called at the beginning of your application.
	//    It initializes DirectX and prepares the engine for rendering.
	[id(SSCLID_INITIALIZEENGINE), helpstring("method InitializeEngine")]
		HRESULT InitializeEngine();

	// Description:
	//    Returns a pointer to the Direct3D rendering engine
	// Parameters:
	//    ppUnk  - Receives the IUnknown pointer to the Direct3D engine
	[id(SSCLID_GET_D3DENGINE), helpstring("method GetD3DEngine")]
		HRESULT GetD3DEngine([out,retval] IUnknown** ppUnk);

	// Description:
	//    Returns the number of rendering devices available on the system
	// Parameters:
	//    Count  - Output parameter that receives the number of rendering
	//             devices
	[id(SSCLID_GET_DEVICECOUNT), helpstring("method GetDeviceCount")]
		HRESULT GetDeviceCount([out,retval] short* Count);

	// Description:
	//    Returns a rendering device
	// Parameters:
	//    DeviceIdx  - Index of the device (zero based)
	//    ppDevice   - Receives a pointer to the rendering device
	// Remarks:
	//    The DeviceIdx parameter is an ordinal value identifying the
	//    device to retrieve. Devices are numbered by the engine from
	//    0 to N-1, where N is the number of rendering devices available
	//    on the system.
	// See Also:
	//    IEngine::GetDeviceCount
	[id(SSCLID_GET_DEVICE), helpstring("method GetDevice")]
		HRESULT GetDevice([in] short DeviceIdx,
		                  [out,retval] IDevice** ppDevice);

	// Description:
	//    Returns the device rendering device
	// Parameters:
	//    ppDevice  - Receives a pointer to the default rendering device
	[id(SSCLID_GET_DEFAULTDEVICE), helpstring("method GetDefaultDevice")]
		HRESULT GetDefaultDevice([out,retval] IDevice** ppDevice);

	// Description:
	//    Returns the number of input devices available on the system
	// Parameters:
	//    DevType   - Category of device
	//    Count     - Receives the number of input devices in the given category
	// Remarks:
	//    Each input device belongs to a category. This function returns the
	//    number of input devices belonging to a given category.
	[id(SSCLID_GET_INPUTDEVICECOUNT), helpstring("method GetInputDeviceCount")]
		HRESULT GetInputDeviceCount([in] enum InputDeviceCategory DevType,
		                            [out,retval] short* Count);

	// Description:
	//    Returns a pointer to an input device
	// Parameters:
	//    DevType     - Input device category
	//    InputDevIdx - Index of device within the given category
	//    InputDev    - Receives a pointer to the input device
	// Remarks:
	//    Each input device belongs to a category. Each input device in a
	//    given category is numbered from 0 to N-1, where N is the number
	//    of input devices in the category.
	// See Also:
	//    IEngine::GetInputDeviceCount
	[id(SSCLID_GET_INPUTDEVICE), helpstring("method GetInputDevice")]
		HRESULT GetInputDevice([in] enum InputDeviceCategory DevType,
		                       [in] short InputDevIdx,
		                       [out,retval] IInputDevice** InputDev);

	// Description:
	//    Version of Direct3D installed on the system.
	[propget, id(SSCLID_DIRECT3D_VERSION), helpstring("property Direct3DVersion")]
		HRESULT Direct3DVersion([out, retval] long* pVal);

	// Description:
	//    Boolean flag indicating if internet access is enabled. ShapeShifter uses
	//    Microsoft's WinINet API to access texture and model files across the
	//    internet. If this property is set to FALSE, WinINet will not be initialized
	//    and internet access is disabled.
	[propget, id(SSCLID_INTERNET_ENABLED), helpstring("property InternetEnabled")]
		HRESULT InternetEnabled([out, retval] VARIANT_BOOL* pVal);

	[propput, id(SSCLID_INTERNET_ENABLED), helpstring("property InternetEnabled")]
		HRESULT InternetEnabled([in] VARIANT_BOOL newVal);

	// Description:
	//    Name of proxy server to use for accessing files across the internet.
	// See Also:
	//    IEngine::InternetEnabled
	[propget, id(SSCLID_PROXY_NAME), helpstring("property ProxyName")]
		HRESULT ProxyName([out, retval] BSTR* pVal);

	[propput, id(SSCLID_PROXY_NAME), helpstring("property ProxyName")]
		HRESULT ProxyName([in] BSTR newVal);

	// Description:
	//    Proxy server bypass address
	// See Also:
	//    IEngine::InternetEnabled
	[propget, id(SSCLID_PROXY_BYPASS), helpstring("property ProxyBypass")]
		HRESULT ProxyBypass([out, retval] BSTR* pVal);

	[propput, id(SSCLID_PROXY_BYPASS), helpstring("property ProxyBypass")]
		HRESULT ProxyBypass([in] BSTR newVal);
};

[
	object,
	uuid(41D8687F-7E12-4E55-AAF4-3D34F1B46D09),
	dual,
	helpstring("IShapeShifterCtl Interface"),
	pointer_default(unique)
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    Interface to the ShapeShifter ActiveX control.
//
// Remarks:
//    All components in ShapeShifter are COM objects that support IDispatch.
//    The ShapeShifter ActiveX control is a full control that supports the
//    interfaces required by ActiveX control containers such as Visual
//    Basic and IE. It encapsulates a model, viewport, controller, and
//    device into a single control that can be placed on a form or in a
//    web page.
//
// See Also:
//    ShapeShifterCtl
////////////////////////////////////////////////////////////////////////////
interface IShapeShifterCtl : IDispatch
{
	// Description:
	//    The driver mode controls whether the device is accessed through the
	//    hardware abstraction layer (HAL), through the reference driver, or
	//    through software emulation.
	[propget, bindable, requestedit, id(SSCLID_DRIVERMODE), helpstring("property DriverMode")]
		HRESULT DriverMode([out,retval] enum DriverMode *Mode);
	[propput, bindable, requestedit, id(SSCLID_DRIVERMODE), helpstring("property DriverMode")]
		HRESULT DriverMode([in] enum DriverMode Mode);

	// Description:
	//    ProgId that identifies the COM class of the model object. The default is
	//    ShapeShifter.Model, but this value can be changed in order to plug-in custom
	//    models.
	[propget, bindable, requestedit, id(SSCLID_MODEL_TYPE), helpstring("property ModelType")]
		HRESULT ModelType([out, retval] BSTR *pVal);
	[propput, bindable, requestedit, id(SSCLID_MODEL_TYPE), helpstring("property ModelType")]
		HRESULT ModelType([in] BSTR newVal);

	// Description:
	//    ProgId that identifies the COM class of the viewport object. The default is
	//    ShapeShifter.Viewport, but this value can be changed in order to plug-in custom
	//    viewports.
	[propget, bindable, requestedit, id(SSCLID_VIEWPORT_TYPE), helpstring("property ViewportType")]
		HRESULT ViewportType([out, retval] BSTR *pVal);
	[propput, bindable, requestedit, id(SSCLID_VIEWPORT_TYPE), helpstring("property ViewportType")]
		HRESULT ViewportType([in] BSTR newVal);

	// Description:
	//    ProgId that identifies the COM class of the controller object. The default is
	//    ShapeShifter.BrowseController, but this value can be changed in order to plug-in custom
	//    controllers.
	[propget, bindable, requestedit, id(SSCLID_CONTROLLER_TYPE), helpstring("property ControllerType")]
		HRESULT ControllerType([out, retval] BSTR *pVal);
	[propput, bindable, requestedit, id(SSCLID_CONTROLLER_TYPE), helpstring("property ControllerType")]
		HRESULT ControllerType([in] BSTR newVal);

	// Description:
	//    This property contains a pointer to the ShapeShifter engine object that is owned
	//    by the control.
	[propget, id(SSCLID_ENGINE), helpstring("property Engine")]
		HRESULT Engine([out, retval] IEngine** pVal);

	// Description:
	//    This property contains a pointer to the ShapeShifter device object that is owned
	//    by the control.
	[propget, id(SSCLID_DEVICE), helpstring("property Device")]
		HRESULT Device([out, retval] IDevice** pVal);

	// Description:
	//    This property contains a pointer to the model object that is owned
	//    by the control.
	[propget, id(SSCLID_MODEL), helpstring("property Model")]
		HRESULT Model([out, retval] IModel** pVal);

	// Description:
	//    This property contains a pointer to the viewport object that is owned
	//    by the control.
	[propget, id(SSCLID_VIEWPORT), helpstring("property Viewport")]
		HRESULT Viewport([out, retval] IViewport** pVal);

	// Description:
	//    This property contains a pointer to the controller object that is owned
	//    by the control.
	[propget, id(SSCLID_CONTROLLER), helpstring("property Controller")]
		HRESULT Controller([out, retval] IController** pVal);

	// Description:
	//    Name of 3D model to load into the control. This property can be NULL or an empty
	//    if the model is to be loaded programmatically.
	[propget, bindable, requestedit, id(SSCLID_MODEL_FILE), helpstring("property ModelFile")]
		HRESULT ModelFile([out, retval] BSTR *pVal);
	[propput, bindable, requestedit, id(SSCLID_MODEL_FILE), helpstring("property ModelFile")]
		HRESULT ModelFile([in] BSTR newVal);

	// Description:
	//    ProgId that identifies the COM class used to read the model.
	[propget, bindable, requestedit, id(SSCLID_MODEL_READER_TYPE), helpstring("property ModelReaderType")]
		HRESULT ModelReaderType([out, retval] BSTR *pVal);
	[propput, bindable, requestedit, id(SSCLID_MODEL_READER_TYPE), helpstring("property ModelReaderType")]
		HRESULT ModelReaderType([in] BSTR newVal);

	// Description:
	//    Background color of the control
	[propput, bindable, requestedit, id(DISPID_BACKCOLOR)]
		HRESULT BackColor([in]OLE_COLOR clr);
	[propget, bindable, requestedit, id(DISPID_BACKCOLOR)]
		HRESULT BackColor([out,retval]OLE_COLOR* pclr);

	// Description:
	//    Boolean flag that indicates if the viewport is windowed or full-screen.
	[propget, bindable, requestedit, id(SSCLID_WINDOWED), helpstring("property Windowed")]
		HRESULT Windowed([out, retval] VARIANT_BOOL *pVal);
	[propput, bindable, requestedit, id(SSCLID_WINDOWED), helpstring("property Windowed")]
		HRESULT Windowed([in] VARIANT_BOOL newVal);

	// Description:
	//    Field of view. This is the camera angle in radians. It helps to define the
	//    frustum (i.e. viewing volume)
	[propget, bindable, requestedit, id(SSCLID_FOV), helpstring("property FOV")]
		HRESULT FOV([out, retval] FLOAT* pVal);
	[propput, bindable, requestedit, id(SSCLID_FOV), helpstring("property FOV")]
		HRESULT FOV([in] FLOAT newVal);

	// Description:
	//    Aspect ratio of the viewport. Ratio of width to height.
	[propget, bindable, requestedit, id(SSCLID_ASPECT), helpstring("property Aspect")]
		HRESULT Aspect([out, retval] FLOAT* pVal);
	[propput, bindable, requestedit, id(SSCLID_ASPECT), helpstring("property Aspect")]
		HRESULT Aspect([in] FLOAT newVal);

	// Description:
	//    Boolean flag that indicates if the aspect ratio should be automatically calculated.
	[propget, bindable, requestedit, id(SSCLID_AUTO_ASPECT), helpstring("property AutoAspect")]
		HRESULT AutoAspect([out, retval] VARIANT_BOOL* pVal);
	[propput, bindable, requestedit, id(SSCLID_AUTO_ASPECT), helpstring("property AutoAspect")]
		HRESULT AutoAspect([in] VARIANT_BOOL newVal);

	// Description:
	//    Distance from the camera to the near plane of the frustum
	[propget, bindable, requestedit, id(SSCLID_NEARPLANE), helpstring("property NearPlane")]
		HRESULT NearPlane([out, retval] FLOAT* pVal);
	[propput, bindable, requestedit, id(SSCLID_NEARPLANE), helpstring("property NearPlane")]
		HRESULT NearPlane([in] FLOAT newVal);

	// Description:
	//    Distance from the camera to the far plane of the frustum
	[propget, bindable, requestedit, id(SSCLID_FARPLANE), helpstring("property FarPlane")]
		HRESULT FarPlane([out, retval] FLOAT* pVal);
	[propput, bindable, requestedit, id(SSCLID_FARPLANE), helpstring("property FarPlane")]
		HRESULT FarPlane([in] FLOAT newVal);

	// Description:
	//    X component of the camera's location
	[propget, id(SSCLID_CAMERA_LOCATION_X), helpstring("property CameraLocationX")]
		HRESULT CameraLocationX([out, retval] FLOAT* pVal);
	[propput, id(SSCLID_CAMERA_LOCATION_X), helpstring("property CameraLocationX")]
		HRESULT CameraLocationX([in] FLOAT newVal);

	// Description:
	//    Y component of the camera's location
	[propget, bindable, requestedit, id(SSCLID_CAMERA_LOCATION_Y), helpstring("property CameraLocationY")]
		HRESULT CameraLocationY([out, retval] FLOAT* pVal);
	[propput, bindable, requestedit, id(SSCLID_CAMERA_LOCATION_Y), helpstring("property CameraLocationY")]
		HRESULT CameraLocationY([in] FLOAT newVal);

	// Description:
	//    Z component of the camera's location
	[propget, bindable, requestedit, id(SSCLID_CAMERA_LOCATION_Z), helpstring("property CameraLocationZ")]
		HRESULT CameraLocationZ([out, retval] FLOAT* pVal);
	[propput, bindable, requestedit, id(SSCLID_CAMERA_LOCATION_Z), helpstring("property CameraLocationZ")]
		HRESULT CameraLocationZ([in] FLOAT newVal);

	// Description:
	//    X component of the camera's aim vector. The aim vector determines what the camera
	//    is pointing at.
	[propget, bindable, requestedit, id(SSCLID_CAMERA_AIM_X), helpstring("property CameraAimX")]
		HRESULT CameraAimX([out, retval] FLOAT* pVal);
	[propput, bindable, requestedit, id(SSCLID_CAMERA_AIM_X), helpstring("property CameraAimX")]
		HRESULT CameraAimX([in] FLOAT newVal);

	// Description:
	//    Y component of the camera's aim vector. The aim vector determines what the camera
	//    is pointing at.
	[propget, bindable, requestedit, id(SSCLID_CAMERA_AIM_Y), helpstring("property CameraAimY")]
		HRESULT CameraAimY([out, retval] FLOAT* pVal);
	[propput, bindable, requestedit, id(SSCLID_CAMERA_AIM_Y), helpstring("property CameraAimY")]
		HRESULT CameraAimY([in] FLOAT newVal);

	// Description:
	//    Z component of the camera's aim vector. The aim vector determines what the camera
	//    is pointing at.
	[propget, bindable, requestedit, id(SSCLID_CAMERA_AIM_Z), helpstring("property CameraAimZ")]
		HRESULT CameraAimZ([out, retval] FLOAT* pVal);
	[propput, bindable, requestedit, id(SSCLID_CAMERA_AIM_Z), helpstring("property CameraAimZ")]
		HRESULT CameraAimZ([in] FLOAT newVal);

	// Description:
	//    X component of the camera's up vector. The up vector is a vector that points out of
	//    the top of the camera and determines the orientation of the camera.
	[propget, bindable, requestedit, id(SSCLID_CAMERA_UP_X), helpstring("property CameraUpX")]
		HRESULT CameraUpX([out, retval] FLOAT* pVal);
	[propput, bindable, requestedit, id(SSCLID_CAMERA_UP_X), helpstring("property CameraUpX")]
		HRESULT CameraUpX([in] FLOAT newVal);

	// Description:
	//    Y component of the camera's up vector. The up vector is a vector that points out of
	//    the top of the camera and determines the orientation of the camera.
	[propget, bindable, requestedit, id(SSCLID_CAMERA_UP_Y), helpstring("property CameraUpY")]
		HRESULT CameraUpY([out, retval] FLOAT* pVal);
	[propput, bindable, requestedit, id(SSCLID_CAMERA_UP_Y), helpstring("property CameraUpY")]
		HRESULT CameraUpY([in] FLOAT newVal);

	// Description:
	//    Z component of the camera's up vector. The up vector is a vector that points out of
	//    the top of the camera and determines the orientation of the camera.
	[propget, bindable, requestedit, id(SSCLID_CAMERA_UP_Z), helpstring("property CameraUpZ")]
		HRESULT CameraUpZ([out, retval] FLOAT* pVal);
	[propput, bindable, requestedit, id(SSCLID_CAMERA_UP_Z), helpstring("property CameraUpZ")]
		HRESULT CameraUpZ([in] FLOAT newVal);

	// Description:
	//    Interval between animation events in milliseconds
	[propget, bindable, requestedit, id(SSCLID_ANIMATION_INTERVAL), helpstring("property AnimationInterval")]
		HRESULT AnimationInterval([out, retval] long *pVal);
	[propput, bindable, requestedit, id(SSCLID_ANIMATION_INTERVAL), helpstring("property AnimationInterval")]
		HRESULT AnimationInterval([in] long newVal);

	// Description:
	//    Boolean flag that determines if animation is enabled
	[propget, bindable, requestedit, id(SSCLID_ANIMATION_ENABLED), helpstring("property AnimationEnabled")]
		HRESULT AnimationEnabled([out, retval] VARIANT_BOOL *pVal);
	[propput, bindable, requestedit, id(SSCLID_ANIMATION_ENABLED), helpstring("property AnimationEnabled")]
		HRESULT AnimationEnabled([in] VARIANT_BOOL newVal);

	// Description:
	//    Boolean flag that determines if collisions are enabled
	[propget, bindable, requestedit, id(SSCLID_COLLISIONS_ENABLED), helpstring("property CollisionsEnabled")]
		HRESULT CollisionsEnabled([out, retval] VARIANT_BOOL *pVal);
	[propput, bindable, requestedit, id(SSCLID_COLLISIONS_ENABLED), helpstring("property CollisionsEnabled")]
		HRESULT CollisionsEnabled([in] VARIANT_BOOL newVal);

	// Description:
	//    Boolean flag that determines if the engine initializes WinINet and allows remote
	//    access of texture and model files
	[propget, bindable, requestedit, id(SSCLID_INTERNET_ENABLED), helpstring("property InternetEnabled")]
		HRESULT InternetEnabled([out, retval] VARIANT_BOOL* pVal);
	[propput, bindable, requestedit, id(SSCLID_INTERNET_ENABLED), helpstring("property InternetEnabled")]
		HRESULT InternetEnabled([in] VARIANT_BOOL newVal);

	// Description:
	//    Causes the control to load the model file specified by the ModelFile property
	[id(SSCLID_LOADFILE), helpstring("method LoadFile")]
		HRESULT LoadFile();

	// Description:
	//    Causes the control to reload the device with the resources in the model
	[id(SSCLID_RELOAD_DEVICE), helpstring("method ReloadDevice")]
		HRESULT ReloadDevice();

	// Description:
	//    Causes the control to render the model and update the screen
	[id(DISPID_REFRESH), helpstring("method Refresh")]
		HRESULT Refresh();

	// Description:
	//    Displays the ShapeShifter about box
	[id(DISPID_ABOUTBOX), helpstring("method AboutBox")]
		HRESULT AboutBox();
};

////////////////////////////////////////////////////////////////////////////////
// Library Section
////////////////////////////////////////////////////////////////////////////////

[
	uuid(D72BD7D1-5F7C-41b4-ADD0-36EF7878440B),
	version(1.0),
	helpstring("ShapeShifter 1.0 Type Library")
]
////////////////////////////////////////////////////////////////////////////
// Description:
//    The ShapeShifter component library is a framework for developing
//    interactive 2D and 3D graphics applications. It provides a retained-
//    mode interface to DirectX and consists of a collection of COM classes
//    and a full ActiveX control.
////////////////////////////////////////////////////////////////////////////
library ShapeShifter
{
	importlib("stdole32.tlb");
	importlib("stdole2.tlb");

	// Import geometry structures as UDTs and force a
	// reference to them so that they are included in
	// the type library.
	import "Geometry3d.idl";
	VECTOR3D;
	POINT3D;
	LINE3D;
	TRIANGLE3D;
	BOX3D;
	SPHERE3D;
	PLANE3D;
	QUAD3D;
	TEXTURECOORDINATE3D;

	[public,uuid(136C49D7-1322-4a29-A0E9-51BB1B4F0DDD)]
	typedef struct DISPLAYMODEINFO
	{
		short Width;
		short Height;
		short RefreshRate;
		short Format;
	} DISPLAYMODEINFO;

	////////////////////////////////////////////////////////////////////////////
	// Force a reference to the following enumerations since they are not
	// explicitly referenced by any interfaces.
	////////////////////////////////////////////////////////////////////////////

	enum RenderStateType;
	enum TextureStageStateType;
	enum TextureFilter;
	enum TextureAddress;

	[
		uuid(EFCE7B67-B2AB-4A0A-BA57-380774FD880F),
		licensed,
		helpstring("ShapeShifter Engine Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    The engine encapsulates access to the Direct3D engine and provides
	//    methods for enumerating the adapters installed on the system.
	//
	// Remarks:
	//    Every ShapeShifter application must have one instance of the
	//    engine class in order to initialize Direct3D. After an application
	//    has created an engine object it must select an adapter and create
	//    a device object for the adapter. An adapter represents a Direct3D
	//    device driver. The GetDefaultDevice method returns the default
	//    adapter for the system and is the easiest way to select an adapter.
	//
	// See Also:
	//    Device
	////////////////////////////////////////////////////////////////////////////
	coclass Engine
	{
		[default] interface IEngine;
	};

	[
		uuid(4631C5EA-582C-4af1-94BC-1A9368AFCCC2),
		helpstring("ShapeShifter Device Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    This class encapsulates the Direct3D device object. It provides
	//    a context for rendering onto an adapter.
	//
	// Remarks:
	//    Device objects are associated with one adapter. It is possible for
	//    there to be more than one device object for a given adapter, however
	//    doing so may have an adverse impact on performance. A device can be
	//    initialized as one of the following three types: SSCL_HAL, SSCL_REF,
	//    and SSCL_SW.
	//
	//    The device class is a relatively thin wrapper around the Direct3D
	//    device object. A pointer to the underlying Direct3D device object
	//    can be retrieved using the IDevice::GetD3DDevice method.
	//
	//    The device object provides caching for device resource objects.
	//    Each resource object is assigned a unique identifier, which can
	//    be to retrieve it during rendering. This allows models to turn
	//    over ownership of device-dependent objects to the device, which
	//    serves to decouple the model from a particular device. This
	//    decoupling makes it possible for the same model to be rendered
	//    onto more than one device. The device implements the
	//    IResourceManagerDX8 (C++ only) interface to provide objects in
	//    the model access to the resource cache.
	//
	//    The device object implements the IPresentationManager (C++ only)
	//    interface to provide a mechanism for managing swap chains and
	//    depth buffers. The IPresentationManager interface is used
	//    primarily by the Viewport class and is an implementation detail
	//    that typical client applications do not need to know about.
	//
	// See Also:
	//    DriverMode
	////////////////////////////////////////////////////////////////////////////
	coclass Device
	{
		[default] dispinterface IDevice;
	};

	[
		uuid(00D89677-8921-4a49-8525-3683525B412E),
		helpstring("ShapeShifter Input Device Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    Encapsulates a DirectInput device.
	//
	// Remarks:
	//
	// See Also:
	////////////////////////////////////////////////////////////////////////////
	coclass InputDevice
	{
		[default] dispinterface IInputDevice;
	};

	[
		uuid(AB21CE97-3FAC-4c7b-8DF5-FD54CE5F71A7),
		helpstring("ShapeShifter Camera Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    This class encapsulates a camera. Cameras are used by the Viewport
	//    class to setup the view matrix.
	//
	// Remarks:
	//    A camera consists of a point and two vectors. The point defines the
	//    location of the camera. One vector is the direction the camera
	//    is pointing (its local Z axis). The other vector is the direction
	//    of the camera's top (its local Y axis). The local X vector can
	//    be derived from the first two vectors.
	//
	//    This class implements an extended C++ only interface called
	//    ICameraEx, which provides a function for generating a view
	//    matrix from the camera settings. ICameraEx is used by the
	//    Viewport class as an internal implementation detail.
	//
	// See Also:
	//    Viewport
	////////////////////////////////////////////////////////////////////////////
	coclass Camera
	{
		[default] dispinterface ICamera;
	};

	[
		uuid(F9567425-545B-48d3-873A-32236B5565D0),
		helpstring("ShapeShifter Windowed Viewport Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    Renders a model onto a rectangular area in a window.
	//
	// Remarks:
	//    A viewport renders a model onto a device. The bounds of a viewport
	//    define the area on the screen (or in the window) on which
	//    rendering occurs. A viewport has a camera, which defines the
	//    position and angle from which the model is viewed. The viewport's
	//    frustum defines the viewing volume and aspect ratio of the view.
	//
	//    Each viewport is associated with a Device. Windowed viewports
	//    always use the current display mode of the associated adapter.
	//
	// See Also:
	//    Device, Camera, Model
	////////////////////////////////////////////////////////////////////////////
	coclass Viewport
	{
		[default] dispinterface IViewport;
	};

	[
		uuid(41809397-CC02-4bb4-B07C-994F3EDC537B),
		helpstring("ShapeShifter Axis Guide Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    A viewport decorator node that draws the X, Y, and Z axes.
	//
	// Remarks:
	//
	// See Also:
	////////////////////////////////////////////////////////////////////////////
	coclass AxisGuide
	{
		[default] dispinterface IVisual;
	};

	[
		uuid(C293DFCA-8C9C-40b7-88FA-1345332109A7),
		helpstring("ShapeShifter Face Array Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    A collection of references to faces in a Mesh.
	//
	// Remarks:
	//     This class provides a way to reference one or more faces in a
	//     Mesh. Face arrays are useful for hit testing and mesh editing.
	//
	// See Also:
	//    Mesh, Primitive
	////////////////////////////////////////////////////////////////////////////
	coclass FaceArray
	{
		[default] dispinterface IFaceArray;
	};

	[
		uuid(AC1B4084-CC50-4ae2-AB56-B4D324FF458A),
		helpstring("ShapeShifter Mesh Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    A mesh is a collection of vertices and rendering primitives that
	//    define a wire frame.
	//
	// Remarks:
	//    Meshes maintain a vertex buffer and a list of primitives. Examples
	//    of primitives are triangle lists, triangle fans, triangle strips,
	//    and point lists. Primitives are indexed - their vertices are
	//    index values into the mesh's vertex buffer. Indexed primitives
	//    are efficient because they decrease the total number of vertices
	//    rendered by sharing duplicate vertices with other primitives.
	//
	//    The Mesh class automatically takes care of sharing duplicate
	//    vertices among primitives. As a mesh is modified (edited),
	//    unused vertices may creep into the vertex buffer. The
	//    IMesh::RemoveUnusedVertices method performs garbage collection
	//    on the vertex buffer. If you use a mesh editor class to edit
	//    the mesh, you won't need to call RemoveUnusedVertices because
	//    mesh editors take care of it for you.
	//
	// See Also:
	//    Primitive, MeshEditor
	////////////////////////////////////////////////////////////////////////////
	coclass Mesh
	{
		[default] dispinterface IMesh;
	};

	////////////////////////////////////////////////////////////////////////////
	// PrelitMesh - Implements a mesh.
	////////////////////////////////////////////////////////////////////////////

	[
		uuid(85BDA184-898C-48f5-83C9-0ABC9999CFB6),
		helpstring("ShapeShifter Prelit Mesh Class")
	]
	coclass PrelitMesh
	{
		[default] dispinterface IMesh;
	};

	[
		uuid(D42A3950-9B43-462f-8CD5-43C8F45DEB34),
		helpstring("_IModelEvents Interface")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    This interface defines the events that can be generated by a model.
	////////////////////////////////////////////////////////////////////////////
	dispinterface _IModelEvents
	{
		properties:
		methods:
		[id(SSCLID_ON_ADD_NODE), helpstring("method OnAddNode")]
			HRESULT OnAddNode([in] INode* Node);

		[id(SSCLID_ON_REMOVE_NODE), helpstring("method OnRemoveNode")]
			HRESULT OnRemoveNode([in] INode* Node);

		[id(SSCLID_ON_MOVE_NODE), helpstring("method OnMoveNode")]
			HRESULT OnMoveNode([in] INode* Node);
	};

	[
		uuid(5573676C-770D-480d-8D8B-60021654FC10),
		helpstring("ShapeShifter BSP Tree Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    Binary space partitioning tree class. BSP trees are used to speed
	//    up hit testing and collision detection.
	//
	// Remarks:
	//
	// See Also:
	//    IBSPTree
	////////////////////////////////////////////////////////////////////////////
	coclass BSPTree
	{
		[default] dispinterface IBSPTree;
	};

	[
		uuid(97A97594-B681-4be4-97C2-8D5326F42B38),
		helpstring("ShapeShifter Model Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    A model is a collection of nodes that are rendered onto a viewport.
	//
	// Remarks:
	//    A model is a hierarchy of nodes such as shapes, textures, materials,
	//    lights, and namespaces. The IModel::CreateNode method is used to
	//    create objects in the hierarchy. Ambient lighting is defined at the
	//    model level. The model also has a rendering context property that
	//    contains model-wide context settings.
	//
	// See Also:
	//    IVisual
	////////////////////////////////////////////////////////////////////////////
	coclass Model
	{
		[default] dispinterface IModel;
		dispinterface IVisual;
		[default,source] dispinterface _IModelEvents;
	};

	[
		uuid(FA8AC8EA-D96B-40f7-B88E-9226DE050827),
		helpstring("ShapeShifter Rendering Context Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    A rendering context contains rendering state flags and other
	//    context objects such as textures and materials.
	//
	// Remarks:
	//    This class can be thought of as a composite context object. Other
	//    context objects such as textures, materials, and texture stages
	//    can be aggregated into a rendering context. The rendering context
	//    also maintains a table of rendering state flags, which correspond
	//    to Direct3D rendering states. The render state type constants and
	//    render state values map directly onto the Direct3D values -
	//    ShapeShifter just passes them directly onto the Direct3D device.
	//
	// See Also:
	//    IMaterial, ITexture, ITextureStage
	////////////////////////////////////////////////////////////////////////////
	coclass RenderingContext
	{
		dispinterface IDispatch;
		[default] dispinterface IRenderingContext;
	};

	[
		uuid(74077B49-8230-4c37-8CC7-11A776446A32),
		helpstring("ShapeShifter Shape Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    A shape transforms a mesh into world coordinates and renders it.
	//
	// Remarks:
	//    Each shape is associated with a single mesh. The shape's
	//    transformation matrix places the mesh into the world's coordinate
	//    space. It is valid for more than one shape to reference the
	//    same mesh.
	//
	//    The shape associates a context object with each primitive in
	//    the mesh. Examples of context object types are RenderingContext,
	//    Texture, TextureStage, and Material. RenderingContext acts as a
	//    composite context object and should be used when multiple context
	//    objects must be applied to a primitive (like a material and a
	//    texture). The shape takes care of selecting each context object
	//    into the device prior to rendering each primitive.
	//
	//    The CompositeShape class supports nesting of shapes and other types
	//    of nodes. The class implements a simple shape without support for
	//    composition.
	//
	// See Also:
	//    INode, IVisual, IRenderingContext, CompositeShape
	////////////////////////////////////////////////////////////////////////////
	coclass Shape
	{
		dispinterface IDispatch;
		dispinterface IVisual;
		[default] dispinterface IShape;
	};

	[
		uuid(29640976-0CDA-4f65-BEF1-985CC523384E),
		helpstring("ShapeShifter Composite Shape Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    This class implements a shape that supports child nodes.
	//
	// Remarks:
	//    This class implements the methods of ICompositeNode to support
	//    aggregation of other nodes. Child nodes can be other shapes,
	//    models, or any other valid type of node. Child nodes that
	//    implement the IRenderDX8 (C++ only) interface are rendered
	//    after the shape renders its own mesh. Child nodes that don't
	//    support the rendering interface are ignored during rendering.
	//
	// See Also:
	//    IShape, ICompositeNode, IVisual, IRenderingContext, Shape
	////////////////////////////////////////////////////////////////////////////
	coclass CompositeShape
	{
		dispinterface IDispatch;
		dispinterface IVisual;
		[default] dispinterface IShape;
	};

	[
		uuid(5B377817-C0AE-4d94-970A-79EE717550FD),
		helpstring("ShapeShifter Group Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    A group is a collection of visual objects that are treated as a
	//    single unit.
	//
	// Remarks:
	//    Groups are similar to composite shapes with a couple of exceptions.
	//    The bounds of a group are defined as the union of the bounds its
	//    children. Individual child nodes in a group cannot be hit tested
	//    or selected. The entire group is treated as a single shape instead
	//    of being treated as a collection of individual shapes.
	//
	// See Also:
	//    IVisual, GroupCommand
	////////////////////////////////////////////////////////////////////////////
	coclass Group
	{
		[default] dispinterface IVisual;
		dispinterface IDispatch;
	};

	[
		uuid(255E0E74-7A70-4d4e-8930-319ECF86D4F2),
		helpstring("ShapeShifter Animation Loop Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    An animation loop fires animation events at a given interval.
	//
	// Remarks:
	//    An animator object is associated with the animation loop. An animator
	//    is any object that implements the IAnimate interface. The animation
	//    loop fires animation events by calling the animator's
	//    IAnimate::Animate method.
	//
	//    The animation loop uses a high-resolution multimedia timer for
	//    accurate firing of animation events.
	//
	// See Also:
	//    IAnimationLoop, IAnimate
	////////////////////////////////////////////////////////////////////////////
	coclass AnimationLoop
	{
		[default] dispinterface IAnimationLoop;
	};

	[
		uuid(C2822E0A-44EE-4201-BD03-2D4D12D692D6),
		helpstring("ShapeShifter CameraFly Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    Behavior that implements animated navigation using the keyboard.
	//
	// Remarks:
	//    Keyboard commands:
	//       * UP arrow    - Move up along the Y axis
	//       * DOWN arrow  - Move down along the Y axis
	//       * LEFT arrow  - Move left along the X axis (strafe left)
	//       * RIGHT arrow - Move right along the X axis (strafe right)
	//       * W           - Move forward along the Z axis
	//       * S           - Move backward along the Z axis
	//       * NUMPAD 8    - Pitch forward around the X axis
	//       * NUMPAD 2    - Pitch backward around the X axis
	//       * NUMPAD 4    - Rotate left around the Y axis
	//       * NUMPAD 6    - Rotate right around the Y axis
	//       * NUMPAD 7    - Roll left around the Z axis
	//       * NUMPAD 9    - Roll right around the Z axis
	//
	// See Also:
	//    ICameraFly, IController
	////////////////////////////////////////////////////////////////////////////
	coclass CameraFly
	{
		[default] dispinterface ICameraFly;
	};

	[
		uuid(C73CDCF2-E94F-4388-BBB3-D95D659FE19F),
		helpstring("ShapeShifter CameraStep Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    Behavior that implements non-animated navigation using the keyboard
	//    and mouse.
	//
	// Remarks:
	//    Keyboard commands:
	//       * UP arrow    - Move up along the Y axis
	//       * DOWN arrow  - Move down along the Y axis
	//       * LEFT arrow  - Move left along the X axis (strafe left)
	//       * RIGHT arrow - Move right along the X axis (strafe right)
	//       * W           - Move forward along the Z axis
	//       * S           - Move backward along the Z axis
	//       * NUMPAD 8    - Pitch forward around the X axis
	//       * NUMPAD 2    - Pitch backward around the X axis
	//       * NUMPAD 4    - Rotate left around the Y axis
	//       * NUMPAD 6    - Rotate right around the Y axis
	//       * NUMPAD 7    - Roll left around the Z axis
	//       * NUMPAD 9    - Roll right around the Z axis
	//       * NUMPAD 5    - Return to upright position parallel to X-Z plane
	//
	//    Mouse commands:
	//       * Mouse wheel - Move forward and backward along Z axis
	//
	// See Also:
	//    ICameraStep, IController
	////////////////////////////////////////////////////////////////////////////
	coclass CameraStep
	{
		[default] dispinterface ICameraStep;
	};

	[
		uuid(78F4D658-5C5B-40f9-A7DD-7A3B88629283),
		helpstring("ShapeShifter KeyboardNavigate Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    Behavior that implements selection of nodes in a model.
	//
	// Remarks:
	//    This behavior processes mouse click and mouse move messages and
	//    performs hit testing on the model in order to populate the
	//    controller's selection list. Clicking the left mouse button on
	//    a node adds the node to the selection list. Clicking the left
	//    mouse button on an area that is empty (i.e. hits no nodes) clears
	//    the selection list. If the MultiSelect property is set to true,
	//    multiple nodes can be selected by holding down the shift key.
	//
	// See Also:
	//    IController
	////////////////////////////////////////////////////////////////////////////
	coclass MouseSelect
	{
		[default] dispinterface ISelectNodes;
	};

	[
		uuid(3010FB89-5D4A-4267-9554-1207B09D43B2),
		helpstring("ShapeShifter DragDrop Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    Behavior that implements drag and drop of nodes in a model.
	//    Controllers that have this behavior allow the user to interactively
	//    move nodes around in the model.
	//
	// Remarks:
	//    The currently selected nodes are moved by the drag and drop operation.
	//    To initiate a drag and drop operation, the client application must
	//    call the IMoveNodes::BeginMove function. Once BeginMove has been
	//    called, tracking rectangles are drawn to track the movement of the
	//    objects. The tracking rectangles can be moved using the mouse or
	//    keyboard. The mouse wheel moves the tracking rectangles in the Z
	//    direction. Keyboard commands can also be used to move the tracking
	//    rectangles. Clicking the left mouse button completes the move by
	//    executing a MoveCommand. Clicking the right mouse button cancels
	//    the operation.
	//
	//    Keyboard commands:
	//
	//       * UP arrow    - Move up along the Y axis
	//       * DOWN arrow  - Move down along the Y axis
	//       * LEFT arrow  - Move left along the X axis
	//       * RIGHT arrow - Move right along the X axis
	//       * W           - Move forward along the Z axis
	//       * S           - Move backward along the Z axis
	//       * RETURN      - Complete the move
	//       * ESC         - Cancel the operation
	//
	// See Also:
	//    IMoveNodes, IBehavior
	////////////////////////////////////////////////////////////////////////////
	coclass DragDrop
	{
		[default] dispinterface IMoveNodes;
	};

	[
		uuid(259A4669-88A6-46ba-863C-A0E3663BA448),
		helpstring("ShapeShifter InsertDeleteNodes Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    Behavior that implements insert and deletion of nodes in a model.
	//    Controllers that have this behavior allow the user to interactively
	//    insert and delete nodes. 
	//
	// Remarks:
	//    In order to insert a node the client application must first call
	//    the InsertNode function, passing the node to insert as a parameter.
	//    This starts the process of tracking the object with the mouse and
	//    keyboard. The mouse can then be moved around to position the tracking
	//    rectangle. The mouse wheel can be used to move the tracking rectangle
	//    in the Z direction. The keyboard can also be used position the
	//    tracking rectangle. If the user presses the left mouse button, the
	//    node is inserted into the model using an InsertCommand object. If
	//    the right mouse button is pressed, the action is cancelled.
	//
	//    The delete command operates on the list currently selected nodes.
	//    When the Delete key is pressed, a DeleteCommand is created, loaded
	//    with the current selection list, and executed.
	//
	// See Also:
	//    IInsertDeleteNodes, IBehavior
	////////////////////////////////////////////////////////////////////////////
	coclass InsertDeleteNodes
	{
		[default] dispinterface IInsertDeleteNodes;
	};

	[
		uuid(1D88942C-B424-42ed-B141-DDE49870675D),
		helpstring("_IControllerEvents Interface")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    This interface defines the events that can be received from
	//    a controller.
	////////////////////////////////////////////////////////////////////////////
	dispinterface _IControllerEvents
	{
		properties:
		methods:
		[id(SSCLID_ON_ANIMATE), helpstring("method OnAnimate")]
			HRESULT OnAnimate([in] long Time, [in] VARIANT_BOOL FirstFrame);

		[id(SSCLID_ON_SELECTION_CHANGE), helpstring("method OnSelectionChange")]
			HRESULT OnSelectionChange([in] INodes* SelectionList);

		[id(SSCLID_ON_NODE_CLICK), helpstring("method OnNodeClick")]
			HRESULT OnNodeClick([in] INode* Node);

		[id(SSCLID_ON_NODE_DBLCLICK), helpstring("method OnNodeDblClick")]
			HRESULT OnNodeDblClick([in] INode* Node);
	};

	[
		uuid(28FEF787-075B-4bc3-8C57-37BD40241DA4),
		helpstring("ShapeShifter Browse Controller Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    This class provides keyboard and mouse navigation for browsing models.
	//
	// Remarks:
	//    This controller has the following behaviors:
	//
	//       * CameraStep
	//       * MouseSelect
	//
	//    This is a non-animation controller, which means that it renders a
	//    new frame only when an event is received that causes a change in
	//    the scene.
	//
	// See Also:
	//    IFirstPersonController, _IControllerEvents, IBehavior
	////////////////////////////////////////////////////////////////////////////
	coclass BrowseController
	{
		[default] dispinterface IFirstPersonController;
		interface IWndMessageReceiver;
		[default,source] dispinterface _IControllerEvents;
	};

	[
		uuid(F2FCC976-AD91-48be-BB9D-D21F6A9FF9C5),
		helpstring("ShapeShifter Browse Edit Controller Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    This class provides navigation and simple editing.
	//
	// Remarks:
	//    This controller has the following behaviors:
	//
	//       * CameraStep
	//       * MouseSelect
	//       * InsertDeleteNodes
	//       * DragDrop
	//
	//    This is a non-animation controller, which means that it renders a
	//    new frame only when an event is received that causes a change in
	//    the scene. This controller allows the user to insert nodes, delete
	//    nodes, select nodes, and move nodes around the scene.
	//
	// See Also:
	//    IFirstPersonController, _IControllerEvents, IBehavior
	////////////////////////////////////////////////////////////////////////////
	coclass BrowseEditController
	{
		[default] dispinterface IFirstPersonController;
		interface IWndMessageReceiver;
		[default,source] dispinterface _IControllerEvents;
	};

	[
		uuid(EDAAB949-85B4-426a-A6D9-8FD2A9BABA3E),
		helpstring("ShapeShifter Flight Controller Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    Navigation controller that implements flight-type controls.
	//
	// Remarks:
	//    This controller has the following behaviors:
	//
	//       * CameraFly
	//
	// See Also:
	//    IFirstPersonController, _IControllerEvents, IBehavior
	////////////////////////////////////////////////////////////////////////////
	coclass FlightController
	{
		[default] dispinterface IFirstPersonController;
		[default,source] dispinterface _IControllerEvents;
	};

	[
		uuid(CF1087BA-726A-4847-A91F-179B22B8E054),
		helpstring("ShapeShifter Material Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    A material node defines the lighting characteristics of a primitive.
	//
	// Remarks:
	//    Materials are context objects that are applied to primitives in a
	//    mesh. Materials can be added to a RenderingContext object or they
	//    can associated directly with a primitive via IShape::SetContext.
	//    Materials define how light reflects off of the faces of a
	//    primitive.
	//
	// See Also:
	//    Shape, RenderingContext
	////////////////////////////////////////////////////////////////////////////
	coclass Material
	{
		[default] dispinterface IMaterial;
	};

	[
		uuid(CBBC253C-A900-438f-A5D4-4066170378DD),
		helpstring("ShapeShifter Texture Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    A texture node encapsulates an image applied to a primitive using
	//    texture mapping.
	//
	// Remarks:
	//    Textures are context objects that are applied to primitives in a
	//    mesh. The texture coordinates of each vertex in the primitive
	//    determine how the image is mapped onto the primitive. Texture
	//    effects such as wrapping, mirroring, clamping, and alpha blending
	//    can be accomplished using TextureStage objects. A TextureStage
	//    object combines a texture with a set of Direct3D texture stage
	//    states. Both textures and texture stages can be further combined
	//    into RenderingContext objects. A texture can be associated directly
	//    with a primitive using IShape::SetContext (i.e. without being
	//    aggregated into a TextureStage or RenderingState object first).
	//    In that case, default texture stage states are used.
	//
	//    Textures can be loaded from files, program resources, or
	//    from memory. The following image file formats are supported:
	//    BMP, TGA, PNG, JPG, DIB, PPM, and DDS.
	//
	// See Also:
	//    Shape, RenderingContext
	////////////////////////////////////////////////////////////////////////////
	coclass Texture
	{
		[default] dispinterface ITexture;
	};

	[
		uuid(F2611596-F756-45fe-B777-9F14061A0D3B),
		helpstring("ShapeShifter TextureStage Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    A texture stage combines a texture with additional state information
	//    to achieve effects such as wrapping, mirroring, clamping, and alpha
	//    blending.
	//
	// Remarks:
	//    The texture stage is associated with one texture through read/write
	//    property. The texture stage maintains a set of texture stage states
	//    that determine the addressing mode for the texture, as well as other
	//    texturing effects.
	//
	// See Also:
	//    Shape, RenderingContext
	////////////////////////////////////////////////////////////////////////////
	coclass TextureStage
	{
		[default] dispinterface ITextureStage;
	};

	[
		uuid(8B66DB90-6421-4f42-B29C-F01401A3DC13),
		helpstring("ShapeShifter Directional Light Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    Encapsulates a directional light.
	//
	// Remarks:
	//    Directional lights have no point of origin and do not attenuate over
	//    distance. A directional light casts light in one direction throughout
	//    the scene and the power of the light is constants throughout the
	//    scene.
	//
	// See Also:
	//    PointLight, SpotLight
	////////////////////////////////////////////////////////////////////////////
	coclass DirectionalLight
	{
		[default] dispinterface ILight;
	};

	[
		uuid(791094E9-B1E6-4dc2-85C3-687123B49FBE),
		helpstring("ShapeShifter Point Light Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    Encapsulates a point light.
	//
	// Remarks:
	//    Point lights give off light in all directions equally from a
	//    particular point. Point lights are affected by attenuation
	//    (i.e. their intensity varies over distance). The distance of
	//    a point light from a given vertex will determine how much light
	//    the vertex receives. A point light is similar to a light bulb.
	//
	// See Also:
	//    ILight, DirectionalLight, SpotLight
	////////////////////////////////////////////////////////////////////////////
	coclass PointLight
	{
		[default] dispinterface ILight;
	};

	[
		uuid(834B55AE-8D7A-4bb9-BA0D-C1AF44CE8F5A),
		helpstring("ShapeShifter Spot Light Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    Encapsulates a spot light.
	//
	// Remarks:
	//    Spotlights have a point of origin and a direction. They are similar
	//    to point lights but only emit light within a conical region of world
	//    space. A desk lamp or a cars headlights are examples of spotlights.
	//    The ISpotLight interface extends ILight and defines methods for
	//    configuring a spotlight.
	//
	// See Also:
	//    ISpotLight, PointLight, DirectionalLight
	////////////////////////////////////////////////////////////////////////////
	coclass SpotLight
	{
		[default] dispinterface ISpotLight;
	};

	[
		uuid(D5318A39-EDF7-4993-A060-3CCC3C9B0DD1),
		helpstring("ShapeShifter Node List Enumerator Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    Enumerator for a list of nodes.
	//
	// See Also:
	//    INodes
	////////////////////////////////////////////////////////////////////////////
	coclass EnumNodeList
	{
		[default] interface IEnumNodes;
	};

	[
		uuid(1F6835D0-FF45-4af1-87BB-C21B5B606EAB),
		helpstring("ShapeShifter Node List Enumerator Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    Enumerator for a list of nodes.
	//
	// See Also:
	//    INodes
	////////////////////////////////////////////////////////////////////////////
	coclass EnumVariantNodeList
	{
		[default] interface IEnumNodes;
	};

	[
		uuid(0AA9E616-1BAB-4d93-8CBA-B352F3527081),
		helpstring("ShapeShifter Node List Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    This class encapsulates a list of nodes.
	//
	// See Also:
	//    INodes, EnumNodeList, EnumVariantNodeList
	////////////////////////////////////////////////////////////////////////////
	coclass NodeList
	{
		[default] dispinterface INodes;
	};

	[
		uuid(E04D586B-F3EA-4b8f-B49D-CC88AD2D7B4A),
		helpstring("ShapeShifter Mesh Editor Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    A mesh editor is an object that modifies the contents of a mesh.
	//
	// Remarks:
	//    The separation of editing functionality from mesh objects into
	//    one or more mesh editor objects provides a great deal of flexibility
	//    and reduces the complexity of mesh objects. This class represents
	//    one type of mesh editor. Other types of mesh editors will be
	//    added as needed and users can create their own mesh editors.
	//
	// See Also:
	//    IMeshEditor, Mesh
	////////////////////////////////////////////////////////////////////////////
	coclass MeshEditor
	{
		[default] dispinterface IMeshEditor;
	};

	[
		uuid(BEED760A-FBD8-46d8-97C7-5116C75A606F),
		helpstring("ShapeShifter Window Message Source Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    Instances of this class tie a window to one or more message receiver
	//    objects.
	//
	// Remarks:
	//    This object is the subject of a subject-observer relationship that
	//    exists between the IWndMessageSource and IWndMessageReceiver
	//    interfaces. Objects that implement IWndMessageReceiver can observe
	//    the message source and receive messages.
	//
	// See Also:
	//    IWndMessageSource, IWndMessageReceiver
	////////////////////////////////////////////////////////////////////////////
	coclass WndMessageSource
	{
		[default] dispinterface IWndMessageSource;
	};

	[
		uuid(6F52F222-A7CA-4697-8BC3-E7DBAF19555E),
		helpstring("ShapeShifter MeasurementScale Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    Encapsulates a conversion scale to convert between logical units
	//    and real world units.
	//
	// Remarks:
	//    The measurement scale properties determine the ratio between
	//    logical units and real world units.
	//
	// See Also:
	//    IMeasurementScale, UnitOfMeasure, Model
	////////////////////////////////////////////////////////////////////////////
	coclass MeasurementScale
	{
		[default] dispinterface IMeasurementScale;
	};

	[
		uuid(DFAA067A-B16C-4b91-8D20-82109D112B92),
		helpstring("ShapeShifter CreateShapeCommand Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    This class implements a command to create a shape and insert it
	//    into the model.
	//
	// See Also:
	//    ICreateShapeCommand, Controller
	////////////////////////////////////////////////////////////////////////////
	coclass CreateShapeCommand
	{
		[default] dispinterface ICreateShapeCommand;
	};

	[
		uuid(107FDFBF-6F28-4fc2-9E1B-F4FFC2B06EE8),
		helpstring("ShapeShifter InsertCommand Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    This class implements a command to insert one or more nodes into
	//    a model.
	//
	// See Also:
	//    IInsertCommand, Controller
	////////////////////////////////////////////////////////////////////////////
	coclass InsertCommand
	{
		[default] dispinterface IInsertCommand;
	};

	[
		uuid(DB58D743-458F-4c1b-B6FD-F952A16B4629),
		helpstring("ShapeShifter DeleteCommand Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    This class implements a command to delete one or more nodes from
	//    a model.
	//
	// See Also:
	//    INodeCommand, Controller
	////////////////////////////////////////////////////////////////////////////
	coclass DeleteCommand
	{
		[default] dispinterface INodeCommand;
	};

	[
		uuid(DB785DE8-F0EC-46a2-94C7-B93FA7294A8F),
		helpstring("ShapeShifter MoveCommand Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    This class implements a command to move one or more nodes in a
	//    model.
	//
	// See Also:
	//    IMoveCommand, Controller
	////////////////////////////////////////////////////////////////////////////
	coclass MoveCommand
	{
		[default] dispinterface IMoveCommand;
	};

	[
		uuid(897CCDDC-5DC3-4a18-8788-F19333F7FC5C),
		helpstring("ShapeShifter RotateCommand Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    This class implements a command to rotate one or more nodes in
	//    a model.
	//
	// See Also:
	//    IRotateCommand, Controller
	////////////////////////////////////////////////////////////////////////////
	coclass RotateCommand
	{
		[default] dispinterface IRotateCommand;
	};

	[
		uuid(26B9C540-72B6-455a-A554-5157A07A69E3),
		helpstring("ShapeShifter ScaleCommand Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    This class implements a command to scale one or more nodes
	//    in a model.
	//
	// Remarks:
	//    This command can be used to scale one or more visual nodes in one
	//    or more directions. Scaling occurs about the local origin of each
	//    object.
	//
	// See Also:
	//    IScaleCommand, Controller
	////////////////////////////////////////////////////////////////////////////
	coclass ScaleCommand
	{
		[default] dispinterface IScaleCommand;
	};

	[
		uuid(ABD700EB-DF69-4615-A1A6-DE1D927C064E),
		helpstring("ShapeShifter GroupCommand Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    This class implements a command to group one or more nodes together
	//    into a single node.
	//
	// Remarks:
	//    This command creates a new Group object and adds the given nodes
	//    to the new group. The nodes to be added to the group are provided
	//    to the group command through the INodeCommand interface. If the
	//    nodes already have a parent, they are removed from their parent
	//    before being added to the group.
	//
	// See Also:
	//    IGroupCommand, Group
	////////////////////////////////////////////////////////////////////////////
	coclass GroupCommand
	{
		[default] dispinterface IGroupCommand;
	};

	[
		uuid(31E82920-A3DF-4178-A389-871D54A6D93F),
		helpstring("ShapeShifter UngroupCommand Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    This class implements a command to dissolve a group node and move the
	//    nodes in the group to the parent node of the group.
	//
	// See Also:
	//    IUngroupCommand, Controller
	////////////////////////////////////////////////////////////////////////////
	coclass UngroupCommand
	{
		[default] dispinterface IUngroupCommand;
	};

	[
		uuid(4F9962EB-4670-4b4f-833B-7EB28E02C780),
		helpstring("ShapeShifter MacroCommand Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    A macro command contains one or more other commands. Macros are
	//    useful for combining multiple commands into a single command.
	//
	// See Also:
	//    IMacroCommand, Controller
	////////////////////////////////////////////////////////////////////////////
	coclass MacroCommand
	{
		[default] dispinterface IMacroCommand;
	};

	[
		uuid(EF4D5D4A-9AC8-43c1-8577-92BE85AE9A64),
		helpstring("ShapeShifter XMLArchive Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    Encapsulates access to the XML DOM. Objects that implement IPersistXML
	//    are passed an XML archive to save and restore themselves to and from.
	//
	// Remarks:
	//    This class contains an XMLDOMDocument object and provides methods for
	//    navigating, reading, and writing the XML document. It maintains a
	//    pointer to the current node in the document. It also implements a
	//    mechanism for caching objects and avoiding circular references.
	//
	// See Also:
	//    IXMLArchive, IPersistXML
	////////////////////////////////////////////////////////////////////////////
	coclass XMLArchive
	{
		[default] dispinterface IXMLArchive;
	};

	[
		uuid(8931527D-D8D5-4475-B7EE-F83A35E86AC4),
		helpstring("ShapeShifter Namespace Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    A namespace is a node that acts as a named container for other nodes.
	//
	// Remarks:
	//    Namespaces are used to group similar nodes together and resolve
	//    naming conflicts.
	//
	// See Also:
	//    ICompositeNode
	////////////////////////////////////////////////////////////////////////////
	coclass Namespace
	{
		[default] dispinterface ICompositeNode;
	};

	[
		uuid(9D9EB2D1-EC61-4006-9C91-B32B1F91FA9C),
		helpstring("ShapeShifter Tracker Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    Visual object for tracking move operations.
	//
	// Remarks:
	//    This is a special type of composite node that exists during drag and
	//    drop operations. It draws a tracking box around the node(s) that are
	//    attached as children.
	//
	// See Also:
	//    IViewport, IVisual
	////////////////////////////////////////////////////////////////////////////
	coclass Tracker
	{
		[default] dispinterface IVisual;
	};

	[
		uuid(87BAC354-DCA1-4e02-9167-F3499471A3AD),
		helpstring("ShapeShifter ModelReader3DS Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    This class implements IModelReader for 3DS files.
	//
	// Remarks:
	//    Loads models from the 3D Studio (3DS) file format.
	//
	// See Also:
	//    IModelReader, Model
	////////////////////////////////////////////////////////////////////////////
	coclass ModelReader3DS
	{
		[default] dispinterface IModelReader;
	};

	[
		uuid(389A46C9-EE2F-4640-80E7-8A2578BE57CA),
		helpstring("ShapeShifter ModelReaderDXF Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    This class implements IModelReader for AutoCad DXF files.
	//
	// Remarks:
	//    Loads models from the AutoCad DXF file format.
	//
	// See Also:
	//    IModelReader, Model
	////////////////////////////////////////////////////////////////////////////
	coclass ModelReaderDXF
	{
		[default] dispinterface IModelReader;
	};

	[
		uuid(12AFBBAE-B811-4917-A71A-A8DC987BBDA4),
		helpstring("ShapeShifter ModelReaderXML Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    Implements IModelReader for ShapeShifter's XML format.
	//
	// Remarks:
	//    This class reads models from the XML DOM.
	//
	// See Also:
	//    IModelReader, Model, ModelWriterXML
	////////////////////////////////////////////////////////////////////////////
	coclass ModelReaderXML
	{
		[default] dispinterface IModelReader;
	};

	[
		uuid(37C15623-478D-4871-8107-2E51DCAAD3C7),
		helpstring("ShapeShifter ModelWriterXML Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    Implements IModelWriter for ShapeShifter's native XML format.
	//
	// Remarks:
	//    This class writes models into the XML DOM in ShapeShifter's
	//    XML serialization format.
	//
	// See Also:
	//    IModelWriter, Model, ModelReaderXML
	////////////////////////////////////////////////////////////////////////////
	coclass ModelWriterXML
	{
		[default] dispinterface IModelWriter;
	};

	[
		uuid(F6115D9F-BA71-416D-B482-6188F9734F08),
		helpstring("_IShapeShifterCtlEvents Interface")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    This interface defined the events that are generated by ShapeShifter
	//    control.
	//
	// See Also:
	//    ShapeShifterCtl
	////////////////////////////////////////////////////////////////////////////
	dispinterface _IShapeShifterCtlEvents
	{
		properties:
		methods:
		[id(SSCLID_ON_SELECTION_CHANGE), helpstring("method OnSelectionChange")]
			HRESULT OnSelectionChange([in] INodes* SelectionList);
	};

	[
		uuid(8DA02F49-0B29-4ec1-8BDE-783F2CB9E39B),
		licensed,
		helpstring("ShapeShifter Control Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    This component is a full, windowed ActiveX control that encapsulates
	//    a model, viewport, device, and controller. It can be inserted into
	//    ActiveX control containers such as Visual Basic and Internet Explorer.
	//
	// Remarks:
	//    This component is essentially a shell for the other components in the
	//    ShapeShifter library. It provides a container window in which to render
	//    the viewport and takes care of creating and connecting the objects
	//    required to render and interact with a model. It also provides the
	//    the ActiveX control interfaces that are required by standard ActiveX
	//    control containers such as Visual Basic and Internet Explorer.
	//
	//    The following interfaces are implemented by this class and make it a
	//    full ActiveX control that can interact with a control container -
	//    IDispatch, IPersistStreamInit, IOleControl, IOleObject,
	//    IOleInPlaceActiveObject, IViewObjectEx, IOleInPlaceObjectWindowless,
	//    ISupportErrorInfo, IConnectionPointContainer, IPersistStorage,
	//    IQuickActivate, IDataObject, and IProvideClassInfo2.
	//
	// See Also:
	//     IShapeShifterCtl, _IShapeShifterCtlEvents, IModel, IViewport,
	//     IController, IDevice
	////////////////////////////////////////////////////////////////////////////
	coclass ShapeShifterCtl
	{
		[default] interface IShapeShifterCtl;
		[default, source] dispinterface _IShapeShifterCtlEvents;
	};

	[
		uuid(6741B546-8D77-4827-B191-F7A1D9E74B5F),
		helpstring("GeneralPropPage Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    General property page for ShapeShifterCtl.
	//
	// See Also:
	//    ShapeShifterCtl
	////////////////////////////////////////////////////////////////////////////
	coclass GeneralPropPage
	{
		interface IUnknown;
	};

	[
		uuid(B6F7ECD1-8485-48bf-A799-5348EEE3A82A),
		helpstring("ViewPropPage Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    Property page that contains viewport properties such as field-of-view,
	//    aspect ratio, near plane, far plane, and background color.
	//
	// See Also:
	//    ShapeShifterCtl
	////////////////////////////////////////////////////////////////////////////
	coclass ViewPropPage
	{
		interface IUnknown;
	};

	[
		uuid(75D201DD-0964-4ada-8B15-195F502BDE2F),
		helpstring("TypesPropPage Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    Property page that contains prog IDs for the type of model, viewport,
	//    controller, and model reader. Used to configure ShapeShifterCtl at
	//    design time.
	//
	// See Also:
	//    ShapeShifterCtl
	////////////////////////////////////////////////////////////////////////////
	coclass TypesPropPage
	{
		interface IUnknown;
	};

	[
		uuid(CCDFE1CE-21A9-4946-B9B5-322855232D9F),
		helpstring("BehaviorPropPage Class")
	]
	////////////////////////////////////////////////////////////////////////////
	// Description:
	//    Property page that contains settings for user interface behavior.
	//
	// See Also:
	//    ShapeShifterCtl
	////////////////////////////////////////////////////////////////////////////
	coclass BehaviorPropPage
	{
		interface IUnknown;
	};
};

